<!-- Author(s): See <authorgroup> in PPC-elf32abi.sgml -->
<!-- Copyright (c) 2011, Power.org -->
<!-- Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.3; with
     no Invariant Sections, with no Front-Cover Texts, and with no Back-Cover 
     Texts. A copy of the license is available in the COPYING.txt file. -->

	<chapter id="LOW-LEVEL"><title>Low Level System Information</title>
	<para></para>
	<sect1 id="MACHINE"><title>Machine Interface</title>
		<para></para>
		<sect2 id="PROCESSOR"><title>Processor Architecture</title>

			<para>This Application Binary Interface (ABI) is not explicitly predicated on a minimum Power ISA version.</para>

			<para>All nonoptional instructions that are defined by the <trademark class="REGISTERED">Power Architecture</trademark>
			can be assumed to be implemented and work as specified.  ABI conforming implementations
			must provide these instructions through software emulation if they are not provided by the
			processor.</para>

			<note><title>note</title><para>Note: The exceptions to this rule are the <emphasis>Fixed-point Load and Store Multiple</emphasis> and
			<emphasis>Fixed-point Move Assist</emphasis> instructions which are not available in little-endian implementations because they
			would cause alignment exceptions.</para></note>

			<para>Processors may support additional instructions beyond the published Instruction Set
			Architecture (ISA) and the Power Architecture optional ones, through <emphasis>Auxiliary
			Processing Units</emphasis> (APUs).  This ABI provides a method for describing the additional
			instructions in section information (see <emphasis><xref linkend="SPECIAL-SECTIONS"></emphasis>
			and <emphasis><xref linkend="APU-INFORMATION-SECTION"></emphasis>) but does not address these
			additional instructions directly and executing them may result in undefined behavior.</para>

			<para>This ABI does not explicitly impose any performance constraints on systems.</para>

		</sect2>
		<sect2 id="DATA-REP"><title>Data Representation</title>
			<sect3 id="BYTEORDER"><title>Byte Ordering</title>
				<para>The following standard data formats are recognized:</para>
				<itemizedlist>
					<listitem>
						<para> 8-bit byte</para>
					</listitem>
					<listitem>
						<para> 16-bit halfword</para>
					</listitem>
					<listitem>
						<para> 32-bit word</para>
					</listitem>
					<listitem>
						<para> 64-bit doubleword</para>
					</listitem>
					<listitem>
						<para> 128-bit quadword</para>
					</listitem>
				</itemizedlist>

				<para>In big-endian byte ordering, the most significant byte is
				located in the lowest addressed byte position in memory (byte 0).
				This byte ordering is alternately referred to as <emphasis>Most Significant Byte</emphasis> (MSB)
				ordering.</para>

				<para>In little-endian byte ordering, the least significant byte is
				located in the lowest addressed byte position in memory (byte 0).  This byte ordering
				is alternately referred to as <emphasis>Least Significant Byte</emphasis> (LSB)
				ordering.</para>

				<para> A specific processor implementation must state which type of byte ordering is
				to be used.</para>

				<note CONDITION="ATR-SPE || ATR-EABI">
					<title>Note</title> 

					<para>Although it is possible on some processors to map some pages as little-endian, and other pages
					as big-endian in the same application, such an application does not conform to
					the ABI.</para>
				</note>


			<para><emphasis><xref linkend="BIT-AND-BYTE-IN-HALFWORDS"></emphasis>, <emphasis><xref
			linkend="BIT-AND-BYTE-IN-WORDS">, </emphasis><emphasis><xref
			linkend="BIT-AND-BYTE-IN-DOUBLEWORDS"></emphasis>, and <emphasis><xref
			linkend="BIT-AND-BYTE-IN-QUADWORDS"></emphasis> show the conventions being assumed in big-endian
			and little-endian byte ordering at the bit and byte levels.  These conventions are applied to
			integer and floating-point data types.  Byte numbers are indicated in the upper corners, and bit
			numbers in the lower corners.  Little-endian byte numbers are indicated on the right side;
			big-endian byte numbers are indicated on the left side.</para>

			<table id="BIT-AND-BYTE-IN-HALFWORDS" frame="all"><title>Bit and Byte Numbering in Halfwords</title>
				<tgroup cols='4' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">1</entry>
						<entry namest="c3">1</entry>
						<entry namest="c4">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>msb</entry>
						<entry namest="c3" nameend="c4" align="center">lsb</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>
				</tbody>
				</tgroup>
			</table>

			<table id="BIT-AND-BYTE-IN-WORDS" frame="all"><title>Bit and Byte Numbering in Words</title>
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">3</entry>
						<entry namest="c3">1</entry>
						<entry namest="c4">2</entry>
						<entry namest="c5">2</entry>
						<entry namest="c6">1</entry>
						<entry namest="c7">3</entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>msb</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center">lsb</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
				</tbody>
				</tgroup>
			</table>

			<table id="BIT-AND-BYTE-IN-DOUBLEWORDS" frame="all"><title>Bit and Byte Numbering in Doublewords</title>
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">1</entry>
						<entry namest="c4">6</entry>
						<entry namest="c5">2</entry>
						<entry namest="c6">5</entry>
						<entry namest="c7">3</entry>
						<entry namest="c8">4</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>msb</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center"></entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1">4</entry>
						<entry namest="c2">3</entry>
						<entry namest="c3">5</entry>
						<entry namest="c4">2</entry>
						<entry namest="c5">6</entry>
						<entry namest="c6">1</entry>
						<entry namest="c7">7</entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'></entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center">lsb</entry>
					</row>	
					<row>
						<entry namest="c1">32</entry>
						<entry namest="c2">39</entry>
						<entry namest="c3">40</entry>
						<entry namest="c4">47</entry>
						<entry namest="c5">48</entry>
						<entry namest="c6">55</entry>
						<entry namest="c7">56</entry>
						<entry namest="c8">63</entry>
					</row>

				</tbody>
				</tgroup>
			</table>

			<table id="BIT-AND-BYTE-IN-QUADWORDS" frame="all"><title>Bit and Byte Numbering in Quadwords</title>
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">15</entry>
						<entry namest="c3">1</entry>
						<entry namest="c4">14</entry>
						<entry namest="c5">2</entry>
						<entry namest="c6">13</entry>
						<entry namest="c7">3</entry>
						<entry namest="c8">12</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>msb</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center"></entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1">4</entry>
						<entry namest="c2">11</entry>
						<entry namest="c3">5</entry>
						<entry namest="c4">10</entry>
						<entry namest="c5">6</entry>
						<entry namest="c6">9</entry>
						<entry namest="c7">7</entry>
						<entry namest="c8">8</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'></entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center"></entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">32</entry>
						<entry namest="c2">39</entry>
						<entry namest="c3">40</entry>
						<entry namest="c4">47</entry>
						<entry namest="c5">48</entry>
						<entry namest="c6">55</entry>
						<entry namest="c7">56</entry>
						<entry namest="c8">63</entry>
					</row>
					<row>
						<entry namest="c1">8</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">9</entry>
						<entry namest="c4">6</entry>
						<entry namest="c5">10</entry>
						<entry namest="c6">5</entry>
						<entry namest="c7">11</entry>
						<entry namest="c8">4</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'></entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center"></entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">64</entry>
						<entry namest="c2">71</entry>
						<entry namest="c3">72</entry>
						<entry namest="c4">79</entry>
						<entry namest="c5">80</entry>
						<entry namest="c6">87</entry>
						<entry namest="c7">88</entry>
						<entry namest="c8">95</entry>
					</row>
					<row>
						<entry namest="c1">12</entry>
						<entry namest="c2">3</entry>
						<entry namest="c3">13</entry>
						<entry namest="c4">2</entry>
						<entry namest="c5">14</entry>
						<entry namest="c6">1</entry>
						<entry namest="c7">15</entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'></entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'></entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center">lsb</entry>
					</row>	
					<row>
						<entry namest="c1">96</entry>
						<entry namest="c2">103</entry>
						<entry namest="c3">104</entry>
						<entry namest="c4">111</entry>
						<entry namest="c5">112</entry>
						<entry namest="c6">119</entry>
						<entry namest="c7">120</entry>
						<entry namest="c8">127</entry>
					</row>

				</tbody>
				</tgroup>
			</table>

			<note>
				<title>Note</title>
				<para>Note: In the Power ISA,
				the figures are generally only shown in big-endian byte order.  The
				bits in these data format specification are numbered from left to
				right (MSB to LSB).</para>
			</note>

			<note CONDITION="ATR-SPE">
				<title>Note</title>

				<para>Note: SPE documentation uses 64-bit numbering throughout,
				including for registers such as the CR that only contain 32 bits.  This numbering
				can lead to some confusion. For example, although the CR bits are now
				numbered from 32 to 63, the same assembly instructions still work:
				<varname>crxor 6,6,6</varname> operates on bit 32 &plus; 6, that is, CR[38]. When discussing
				register contents, the bits are numbered 0 : 63 for 64-bit registers
				and 32 : 63 for 32-bit registers. When discussing memory contents, the
				bits are numbered naturally (for example, 0 : 7 for bits within one
				byte and 0 : 15 for bits within halfwords).</para>
			</note>

			<para>The bit numbering in the Power ISA is all 64-bit except for the following registers indicated in Power ISA section 1.4:</para>
			<itemizedlist>
				<listitem>
					<para>Opcodes marking 0-31</para>
				</listitem>
				<listitem CONDITION="ATR-VECTOR">
					<para>Vector registers and the VSCR (see <emphasis><xref linkend="REG"></emphasis>).</para>
				</listitem>
				<listitem CONDITION="ATR-CLASSIC-FLOAT">

					<para>As of Power ISA version 2.05 the FPSCR has been extended from 32-bits to 64-bits.
					The fields of the original 32-bit FPSCR are now held in bits 32-63 of the 64-bit
					FPSCR.  The assembly instructions which operate upon the 64-bit FPSCR have
					either had a <emphasis>W Instruction Field</emphasis> added to select the
					operative word for the instruction, e.g., <varname>mtfsfi</varname>, or the
					instruction has been extended to operate upon the entire 64-bit FPSCR, e.g.,
					<varname>mffs</varname>.  Reference to fields of the FPSCR, representing 1 or
					more bits, is done by field number with an indication of the operative word
					rather than by bit-number.</para> <para>If the Power ISA version 2.05 DFP category is
					not needed by an implementation the FPSCR may continue to be referenced as a
					32-bit register using the old forms of the instructions to support binary
					compatibility of ELF files built against an older Power ISA version. See <emphasis><xref linkend="REG"></emphasis> for more information on the
					FPSCR.</para>

				</listitem>
			</itemizedlist>
		</sect3>
		<sect3 id="FUNDAMENTAL-TYPES"><title>Fundamental Types</title>

			<para>The following tables map the data format specifications described
			in the Power ISA to ISO C scalar types.  Each scalar type has a
			required alignment, which is indicated in the alignment column. Usage
			of these types in data structures must follow the alignment specified in
			the order encountered to ensure consistent mapping. When using variables
			individually, more strict alignment may be imposed if it has
			optimization benefits.</para>

			<table id="FUNDAMENTAL-TYPES-TABLE" frame="none"><title>Fundamental Types</title>
				<tgroup cols='5' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='95' colname='c2' align="left">
					<colspec colwidth='40' colname='c3' align="left">
					<colspec colwidth='60' colname='c4' align="left">
					<colspec colwidth='130' colname='c5' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1" rowsep='1'>Type</entry>
							<entry namest="c2" rowsep='1'>ISO C Types</entry>
							<entry namest="c3" rowsep='1'>sizeof</entry>
							<entry namest="c4" rowsep='1'>Alignment</entry>
							<entry namest="c5" rowsep='1'>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1" rowsep='1'>Boolean</entry>
							<entry namest="c2" rowsep='1'>_Bool</entry>
							<entry namest="c3" rowsep='1'>1</entry>
							<entry namest="c4" rowsep='1'>byte</entry>
							<entry namest="c5" rowsep='1'>boolean</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>Character</entry>
							<entry namest="c2" rowsep='0'>char</entry>
							<entry namest="c3" rowsep='0'>1</entry>
							<entry namest="c4" rowsep='0'>byte</entry>
							<entry namest="c5" rowsep='0'>unsigned byte</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>unsigned char</entry>
							<entry namest="c3" rowsep='1'></entry>
							<entry namest="c4" rowsep='1'></entry>
							<entry namest="c5" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>signed char</entry>
							<entry namest="c3" rowsep='1'>1</entry>
							<entry namest="c4" rowsep='1'>byte</entry>
							<entry namest="c5" rowsep='1'>signed byte</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='0'>short</entry>
							<entry namest="c3" rowsep='0'>2</entry>
							<entry namest="c4" rowsep='0'>halfword</entry>
							<entry namest="c5" rowsep='0'>signed halfword</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>signed short</entry>
							<entry namest="c3" rowsep='1'></entry>
							<entry namest="c4" rowsep='1'></entry>
							<entry namest="c5" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='1'></entry>
							<entry namest="c2" rowsep='1'>unsigned short</entry>
							<entry namest="c3" rowsep='1'>2</entry>
							<entry namest="c4" rowsep='1'>halfword</entry>
							<entry namest="c5" rowsep='1'>unsigned halfword</entry>
						</row>

						<row>
							<entry namest="c1" rowsep='0'>Enumeration</entry>
							<entry namest="c2" rowsep='1'>signed enum</entry>
							<entry namest="c3" rowsep='1'>4</entry>
							<entry namest="c4" rowsep='1'>word</entry>
							<entry namest="c5" rowsep='1'>signed word</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='1'></entry>
							<entry namest="c2" rowsep='1'>unsigned enum</entry>
							<entry namest="c3" rowsep='1'>4</entry>
							<entry namest="c4" rowsep='1'>word</entry>
							<entry namest="c5" rowsep='1'>unsigned word</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>Integral</entry>
							<entry namest="c2" rowsep='0'>int</entry>
							<entry namest="c3" rowsep='0'>4</entry>
							<entry namest="c4" rowsep='0'>word</entry>
							<entry namest="c5" rowsep='0'>signed word</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='0'>signed int</entry>
							<entry namest="c3" rowsep='0'></entry>
							<entry namest="c4" rowsep='0'></entry>
							<entry namest="c5" rowsep='0'></entry>
						</row>
						<row>
							<entry namest="c2" rowsep='0'>long int</entry>
							<entry namest="c3" rowsep='0'></entry>
							<entry namest="c4" rowsep='0'></entry>
							<entry namest="c5" rowsep='0'></entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>signed long</entry>
							<entry namest="c3" rowsep='1'></entry>
							<entry namest="c4" rowsep='1'></entry>
							<entry namest="c5" rowsep='1'></entry>
						</row>

						<row>
							<entry namest="c2" rowsep='0'>unsigned int</entry>
							<entry namest="c3" rowsep='0'>4</entry>
							<entry namest="c4" rowsep='0'>word</entry>
							<entry namest="c5" rowsep='0'>unsigned word</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>unsigned long</entry>
							<entry namest="c3" rowsep='1'></entry>
							<entry namest="c4" rowsep='1'></entry>
							<entry namest="c5" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c2" rowsep='0'>long long</entry>
							<entry namest="c3" rowsep='0'>8</entry>
							<entry namest="c4" rowsep='0'>doubleword</entry>
							<entry namest="c5" rowsep='0'>signed doubleword</entry>
						</row>

						<row>
							<entry namest="c2" rowsep='1'>signed long long</entry>
							<entry namest="c3" rowsep='1'></entry>
							<entry namest="c4" rowsep='1'></entry>
							<entry namest="c5" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='1'></entry>
							<entry namest="c2" rowsep='1'>unsigned long long</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>unsigned doubleword</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>Pointer</entry>
							<entry namest="c2" rowsep='0'>any *</entry>
							<entry namest="c3" rowsep='0'>4</entry>
							<entry namest="c4" rowsep='0'>word</entry>
							<entry namest="c5" rowsep='0'>unsigned word</entry>

						</row>
						<row>
							<entry namest="c1" rowsep='1'></entry>
							<entry namest="c2" rowsep='1'>any (*) ()</entry>
							<entry namest="c3" rowsep='1'></entry>
							<entry namest="c4" rowsep='1'></entry>
							<entry namest="c5" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>Floating</entry>
							<entry namest="c2" rowsep='1'>float</entry>
							<entry namest="c3" rowsep='1'>4</entry>
							<entry namest="c4" rowsep='1'>word</entry>
							<entry namest="c5" rowsep='1'>single-precision float</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'></entry>
							<entry namest="c2">double</entry>
							<entry namest="c3">8</entry>
							<entry namest="c4">doubleword</entry>
							<entry namest="c5">double-precision float</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<important><para>A NULL pointer has all bits zero.</para></important>

			<note><title>Note</title><para>Note: A boolean value is represented as a byte
			with value 0 or 1.  If a byte with a value other than 0 or 1 is
			evaluated as a boolean value (for example, through the use of unions),
			the behavior is undefined.</para></note>

			<note><title>Note</title><para>Note: If an enumerated type contains a
			negative value, it is compatible with and has the same representation
			and alignment as int; otherwise it is compatible with and has the same
			representation and alignment as unsigned int.</para></note>

			<note><title>Note</title><para>Note: For each real floating-point type
			there is a corresponding complex type.  This has the same alignment as
			the real type and twice the size; the representation is the real part
			followed by the imaginary part.</para></note>

			<table id="SPE-TYPES-TABLE" frame="none" CONDITION="ATR-SPE"><title>SPE Types</title>
				<tgroup cols='5' colsep='0' rowsep='0'>
					<colspec colwidth='50' colname='c1' align="left">
					<colspec colwidth='105' colname='c2' align="left">
					<colspec colwidth='40' colname='c3' align="left">
					<colspec colwidth='60' colname='c4' align="left">
					<colspec colwidth='130' colname='c5' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Type</entry>
							<entry namest="c2">SPEPIM C Types</entry>
							<entry namest="c3">sizeof</entry>
							<entry namest="c4">Alignment</entry>
							<entry namest="c5">Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1" rowsep='0'>vector-64</entry>
							<entry namest="c2" rowsep='1'>__ev64_u16__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>vector of four unsigned halfwords</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>__ev64_s16__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>vector of four signed halfwords</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>__ev64_u32__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>vector of two unsigned words</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>__ev64_s32__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>vector of two signed words</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>__ev64_fs__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>vector of two single-precision floats</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>__ev64_u64__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>1 unsigned doubleword</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>__ev64_s64__</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>1 signed doubleword</entry>
						</row>
						<row rowsep='0'>
							<entry namest="c1"></entry>
							<entry namest="c2">&lowbar;&lowbar;ev64&lowbar;opaque&lowbar;&lowbar;</entry>
							<entry namest="c3">8</entry>
							<entry namest="c4">doubleword</entry>
							<entry namest="c5">any of the above</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<table id="VECTOR-TYPES-TABLE" frame="none" CONDITION="ATR-VECTOR"><title>Vector Types</title>
				<tgroup cols='5' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='95' colname='c2' align="left">
					<colspec colwidth='40' colname='c3' align="left">
					<colspec colwidth='60' colname='c4' align="left">
					<colspec colwidth='130' colname='c5' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Type</entry>
							<entry namest="c2">ALTIVECPIM C Types</entry>
							<entry namest="c3">sizeof</entry>
							<entry namest="c4">Alignment</entry>
							<entry namest="c5">Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1" rowsep='0'>vector-128</entry>
							<entry namest="c2" rowsep='1'>vector unsigned char</entry>
							<entry namest="c3" rowsep='1'>16</entry>
							<entry namest="c4" rowsep='1'>quadword</entry>
							<entry namest="c5" rowsep='1'>vector of sixteen unsigned bytes</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>vector signed char</entry>
							<entry namest="c3" rowsep='1'>16</entry>
							<entry namest="c4" rowsep='1'>quadword</entry>
							<entry namest="c5" rowsep='1'>vector of sixteen signed bytes</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>vector unsigned short</entry>
							<entry namest="c3" rowsep='1'>16</entry>
							<entry namest="c4" rowsep='1'>quadword</entry>
							<entry namest="c5" rowsep='1'>vector of eight unsigned halfwords</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>vector signed short</entry>
							<entry namest="c3" rowsep='1'>16</entry>
							<entry namest="c4" rowsep='1'>quadword</entry>
							<entry namest="c5" rowsep='1'>vector of eight signed halfwords</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>vector unsigned int</entry>
							<entry namest="c3" rowsep='1'>16</entry>
							<entry namest="c4" rowsep='1'>quadword</entry>
							<entry namest="c5" rowsep='1'>vector of four unsigned words</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>vector signed int</entry>
							<entry namest="c3" rowsep='1'>16</entry>
							<entry namest="c4" rowsep='1'>quadword</entry>
							<entry namest="c5" rowsep='1'>vector of four signed words</entry>
						</row>
						<row rowsep='0'>
							<entry namest="c1"></entry>
							<entry namest="c2">vector float</entry>
							<entry namest="c3">16</entry>
							<entry namest="c4">quadword</entry>
							<entry namest="c5">vector of four single-precision floats</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

			<note CONDITION="ATR-SPE && ATR-VECTOR">
				<title>Note</title> 
				<para>Note: Availability of Vector
				data types is subject to conformance to a Power ISA category where the
				categories &ldquo;Vector&rdquo; and &ldquo;SPE&rdquo; are mutually exclusive.</para></note>


			<table id="DFP-TYPES-TABLE" frame="none" CONDITION="ATR-DFP"><title>Decimal Floating-Point Types</title>
				<tgroup cols='5' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='95' colname='c2' align="left">
					<colspec colwidth='40' colname='c3' align="left">
					<colspec colwidth='60' colname='c4' align="left">
					<colspec colwidth='130' colname='c5' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Type</entry>
							<entry namest="c2">ISO TR 24732 C Types</entry>
							<entry namest="c3">sizeof</entry>
							<entry namest="c4">Alignment</entry>
							<entry namest="c5">Description</entry>
						</row>
					</thead>
					<tbody>
						<row rowsep="1">
							<entry namest="c1" rowsep='0'>Decimal Floating</entry>
							<entry namest="c2" rowsep='1'>_Decimal32</entry>
							<entry namest="c3" rowsep='1'>4</entry>
							<entry namest="c4" rowsep='1'>word</entry>
							<entry namest="c5" rowsep='1'>single-precision decimal float</entry>
						</row>
						<row>
							<entry namest="c2" rowsep='1'>_Decimal64</entry>
							<entry namest="c3" rowsep='1'>8</entry>
							<entry namest="c4" rowsep='1'>doubleword</entry>
							<entry namest="c5" rowsep='1'>double-precision decimal float</entry>
						</row>
						<row rowsep='0'>
							<entry namest="c2">_Decimal128</entry>
							<entry namest="c3">16</entry>
							<entry namest="c4">quadword</entry>
							<entry namest="c5">quad-precision decimal float</entry>
						</row> 
					</tbody>
					</tgroup>
			</table>

			<table id="LONG-DOUBLE-IS-IBM-TYPES-TABLE" frame="none" CONDITION="ATR-LONG-DOUBLE-IBM"><title><trademark class="REGISTERED">IBM</trademark> <trademark class="registered">AIX</trademark> Long Double 128 Type</title>
				<tgroup cols='5' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='95' colname='c2' align="left">
					<colspec colwidth='40' colname='c3' align="left">
					<colspec colwidth='60' colname='c4' align="left">
					<colspec colwidth='130' colname='c5' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Type</entry>
							<entry namest="c2">ISO C Types</entry>
							<entry namest="c3">sizeof</entry>
							<entry namest="c4">Alignment</entry>
							<entry namest="c5">Description</entry>
						</row>
					</thead>
					<tbody>
						<row rowsep="0">
							<entry namest="c1">IBM AIX long double</entry>
							<entry namest="c2">long double</entry>
							<entry namest="c3">16</entry>
							<entry namest="c4">quadword</entry>
							<entry namest="c5">two double-precision floats</entry>
						</row>
					</tbody>
					</tgroup>
			</table>


			<table id="LONG-DOUBLE-IS-DOUBLE-TYPES-TABLE" frame="none" CONDITION="ATR-LONG-DOUBLE-IS-DOUBLE"><title>Long Double Is Double Type</title>
				<tgroup cols='5' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='95' colname='c2' align="left">
					<colspec colwidth='40' colname='c3' align="left">
					<colspec colwidth='60' colname='c4' align="left">
					<colspec colwidth='130' colname='c5' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Type</entry>
							<entry namest="c2">ISO C Types</entry>
							<entry namest="c3">sizeof</entry>
							<entry namest="c4">Alignment</entry>
							<entry namest="c5">Description</entry>
						</row>
					</thead>
					<tbody>
						<row rowsep='0'>
							<entry namest="c1">long double is double</entry>
							<entry namest="c2">long double</entry>
							<entry namest="c3">8</entry>
							<entry namest="c4">doubleword</entry>
							<entry namest="c5">double-precision float</entry>
						</row>
					</tbody>
					</tgroup>
			</table>

			<note CONDITION="ATR-LONG-DOUBLE-IBM && ATR-LONG-DOUBLE-IS-DOUBLE">
				<title>Note</title> 

				<para>Note: Availability of the long
				double data type is subject to conformance to a long double standard
				where the IBM AIX 128-bit
				Long Double format and the <emphasis>Long Double is Double</emphasis> format are mutually
				exclusive.</para>

			</note>


			<note CONDITION="ATR-LONG-DOUBLE-IS-DOUBLE || ATR-LONG-DOUBLE-IBM">
				<title>Note</title>

				<para> This ABI provides the following choices for implementation of
				long double in compilers and systems:</para>

				<itemizedlist>
					<listitem CONDITION="ATR-LONG-DOUBLE-IS-DOUBLE">
						<para>Do not support any floating-point types with greater
						precision than double.  In this case, long doubles and doubles have the same
						size and precision. </para>
					</listitem>
					<listitem CONDITION="ATR-LONG-DOUBLE-IBM">
						<para> Provide support for the IBM AIX 128-bit Long Double format. In
						this format, double precision numbers with different magnitudes
						that do not overlap, provide an effective precision of 106-bits.
						The high-order double-precision value (the one that comes first in
						storage) must have the larger magnitude.  The high-order double-precision value must equal the sum of the two values, rounded to
						nearest double.</para>

						<itemizedlist>
							<listitem>
								<para>Extended precision provides the same range of double-precision (about 10<superscript>&minus;308</superscript> to 10<superscript>308</superscript> but more precision (a variable amount, about 31 decimal digits or more).
								</para>
							</listitem>
							<listitem>
								<para> As the absolute value of the magnitude decreases (near the denormal range), the
								precision available in the low-order double also decreases.  </para>
							</listitem>
							<listitem>
								<para> When the value represented is in the denormal range, this representation
								provides no more precision than 64-bit (double) floating-point.</para>
							</listitem>
							<listitem>
								<para> The actual number of bits of precision can vary.  If the low-order part is much
								less then 1 unit of least precision (ULP) of the high-order part, significant bits (either all 0s or all 1s)
								are implied between the significands of high-order and low-order numbers.  Some
								algorithms that rely on having a fixed number of bits in the significand can fail when
								using extended-precision.</para>
							</listitem>
						</itemizedlist>

						<para> This implementation differs from the IEEE 754 Standard in the following ways:</para>
						<itemizedlist>
							<listitem>
								<para> The software support is restricted to round-to-nearest mode.  Programs that use
								extended-precision must ensure that this rounding mode is in effect when
								extended-precision calculations are performed.</para>
							</listitem>
							<listitem>
								<para> Does not fully support the IEEE special numbers NaN and INF.  These values are
								encoded in the high-order double value only.  The low-order
								value is not significant, but the low-order value of an
								infinity must be positive or negative zero.
								</para>
							</listitem>
							<listitem>
								<para> Does not support the IEEE status flags for overflow, underflow, and other
								conditions.  These flags have no meaning in this format.</para>
							</listitem>
						</itemizedlist>
					</listitem>
				</itemizedlist>
			</note>
		</sect3>
		<sect3 id="AGG-UNION"><title>Aggregates and Unions</title>
			<para>The following are the rules for aggregates (structures and arrays)
			and unions that apply to their alignment and size.</para>

			<itemizedlist>
				<listitem>
					<para>The entire aggregate or union must be aligned to its most strictly aligned
					member, which corresponds to the member with the largest alignment, including flexible array members.</para>
				</listitem>
				<listitem>
					<para>Each member is assigned the lowest available offset that meets the alignment
					requirements of the member. Depending on the previous member, internal padding can be
					required.</para>
				</listitem>
				<listitem>
					<para>The entire aggregate or union must have a size that is a multiple of its
					alignment. Depending on the last member, tail padding can be required.</para>
				</listitem>
			</itemizedlist>

			<para>For the following figures, the big-endian byte offsets are located in the upper left
					corners, and the little-endian byte offsets are located in the upper right corners.</para>
			<figure><title>Structure Smaller Than a Word</title>
				<programlisting>
struct {
   char c;
};
				</programlisting>
				<synopsis>byte aligned, sizeof is 1</synopsis>
</figure>
				<informaltable frame="all">
					<tgroup cols='2' colsep='0' rowsep='0'>
					<colspec colwidth="15" colname='c1' align="left">
					<colspec colwidth="15" colname='c2' align="right">
					<tbody>
						<row>
							<entry namest="c1">0</entry>
							<entry namest="c2">0</entry>
						</row>
						<row>
							<entry namest="c1" nameend="c2" align="center">c</entry>
						</row>	
					</tbody>
					</tgroup>
				</informaltable>

			<figure><title>Structure With No Padding</title>
				<programlisting>
struct {
  char  c;
  char  d;
  short s;
  int   n;
};
				</programlisting>
				<synopsis>word-aligned, sizeof is 8</synopsis>
			</figure>

			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c4" align="right" colsep="1">2</entry>
						<entry namest="c5" nameend="c6" align="right" colsep="1">1</entry>
						<entry namest="c7" nameend="c8" align="right">0</entry>
					</row>
					<row rowsep="1">
						<entry namest="c1" nameend="c4" colsep="1" align="center">s</entry>
						<entry namest="c5" nameend="c6" colsep="1" align="center">d</entry>
						<entry namest="c7" nameend="c8" align="center">c</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="right">4</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="center">n</entry>
					</row>	

				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c2" colsep="1" align="left">0</entry>
						<entry namest="c3" nameend="c4" colsep="1" align="left">1</entry>
						<entry namest="c5" nameend="c8" align="left">2</entry>
					</row>
					<row rowsep="1">
						<entry namest="c1" nameend="c2" colsep="1" align="center">c</entry>
						<entry namest="c3" nameend="c4" colsep="1" align="center">d</entry>
						<entry namest="c5" nameend="c8" align="center">s</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="left">4</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="center">n</entry>
					</row>	

				</tbody>
				</tgroup>
			</informaltable>


				<figure><title>Structure With Internal Padding</title>
				<programlisting>
struct {
  char  c;
  short s;
};
				</programlisting>
				<synopsis>halfword-aligned, sizeof is 4</synopsis>
			</figure>
			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c4" align="right" colsep="1">2</entry>
						<entry namest="c5" nameend="c6" align="right" colsep="1">1</entry>
						<entry namest="c7" nameend="c8" align="right">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c4" colsep="1" align="center">s</entry>
						<entry namest="c5" nameend="c6" colsep="1" align="center">pad</entry>
						<entry namest="c7" nameend="c8" align="center">c</entry>
					</row>	
				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c2" colsep="1" align="left">0</entry>
						<entry namest="c3" nameend="c4" colsep="1" align="left">1</entry>
						<entry namest="c5" nameend="c8" align="left">2</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" colsep="1" align="center">c</entry>
						<entry namest="c3" nameend="c4" colsep="1" align="center">pad</entry>
						<entry namest="c5" nameend="c8" align="center">s</entry>
					</row>	
				</tbody>
				</tgroup>
			</informaltable>




			<figure><title>Structure With Internal and Tail Padding</title>
				<programlisting>
struct {
 char   c;
 double d;
 short  s;
};
				</programlisting>
				<synopsis>doubleword-aligned, sizeof is 24</synopsis>

			</figure>
			<para>little-endian</para>

			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c6" align="right" colsep="1">1</entry>
						<entry namest="c7" nameend="c8" align="right">0</entry>
					</row>
					<row rowsep="1">
						<entry namest="c1" nameend="c6" colsep="1" align="center">pad</entry>
						<entry namest="c7" nameend="c8" align="center">c</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="right">4</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">pad</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="right">8</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">d</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="right">12</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">d</entry>
					</row>	

					<row>
						<entry namest="c1" nameend="c4" colsep="1" align="right">18</entry>
						<entry namest="c5" nameend="c8" align="right">16</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c4" colsep="1" align="center">pad</entry>
						<entry namest="c5" nameend="c8" align="center">s</entry>
					</row>	

					<row>
						<entry namest="c1" nameend="c8" align="right">20</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">pad</entry>
					</row>	
				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c2" colsep="1" align="left">0</entry>
						<entry namest="c3" nameend="c8" colsep="1" align="left">1</entry>
					</row>
					<row rowsep="1">
						<entry namest="c1" nameend="c2" colsep="1" align="center">c</entry>
						<entry namest="c3" nameend="c8" colsep="1" align="center">pad</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="left">4</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">pad</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="left">8</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">d</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="left">12</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">d</entry>
					</row>	

					<row>
						<entry namest="c1" nameend="c4" align="left" colsep="1">16</entry>
						<entry namest="c5" nameend="c8" align="left">18</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c4" align="center" colsep="1">s</entry>
						<entry namest="c5" nameend="c8" align="center">pad</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="left">20</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">pad</entry>
					</row>	
				</tbody>
				</tgroup>
			</informaltable>


			<figure><title>Union Allocation</title>
				<programlisting>
union {
  char  c;
  short s;
  int   j;
};
				</programlisting>
				<synopsis>word-aligned, sizeof is 4</synopsis></figure>
			<para>little-endian</para>

			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c6" align="right" colsep="1">1</entry>
						<entry namest="c7" nameend="c8" align="right">0</entry>
					</row>
					<row rowsep="1">
						<entry namest="c1" nameend="c6" colsep="1" align="center">pad</entry>
						<entry namest="c7" nameend="c8" align="center">c</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c4" colsep="1" align="right">2</entry>
						<entry namest="c5" nameend="c8" align="right">0</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c4" colsep="1" align="center">pad</entry>
						<entry namest="c5" nameend="c8" align="center">s</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c8" align="right">0</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">j</entry>
					</row>	
				</tbody>
				</tgroup>
			</informaltable>
			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth='15' colname='c1' align="left">
				<colspec colwidth='15' colname='c2' align="right">
				<colspec colwidth='15' colname='c3' align="left">
				<colspec colwidth='15' colname='c4' align="right">
				<colspec colwidth='15' colname='c5' align="left">
				<colspec colwidth='15' colname='c6' align="right">
				<colspec colwidth='15' colname='c7' align="left">
				<colspec colwidth='15' colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c2" colsep="1" align="left">0</entry>
						<entry namest="c3" nameend="c8" colsep="1" align="left">1</entry>
					</row>
					<row rowsep="1">
						<entry namest="c1" nameend="c2" colsep="1" align="center">c</entry>
						<entry namest="c3" nameend="c8" colsep="1" align="center">pad</entry>
					</row>	
					<row>
						<entry namest="c1" nameend="c4" align="left" colsep="1">0</entry>
						<entry namest="c5" nameend="c8" align="left">2</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c4" align="center" colsep="1">s</entry>
						<entry namest="c5" nameend="c8" align="center">pad</entry>
					</row>	

					<row>
						<entry namest="c1" nameend="c8" align="left">0</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1" nameend="c8" align="center">j</entry>
					</row>	
				</tbody>
				</tgroup>
			</informaltable>
		</sect3>

		<sect3 id="BITFIELD"><title>Bit-fields</title>
			<para>Bit-fields can be present in definitions of C structures and
			unions.  These bit-fields define whole objects within the structure or
			union where the number of bits in the bit-field is specified.</para>

			<para>In the following table, a signed range goes from
			&minus;(2<superscript>(<emphasis>w</emphasis> &dash; 1)</superscript>) to
			(2<superscript>(<emphasis>w</emphasis> &dash; 1)</superscript>) &dash; 1 and an unsigned range
			goes from 0 to (2<superscript><emphasis>w</emphasis></superscript>) &dash; 1.</para>

			<table id="BIT-FIELDS-TABLE" frame="none"><title>Bit-Field Types</title>
				<tgroup cols='2' colsep='0' rowsep='0'>
					<colspec colwidth='95' colname='c1' align="left" rowsep='1'>
					<colspec colwidth='60' colname='c2' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Bit-field Type</entry>
							<entry namest="c2">Width (w)</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1" rowsep='1'>_Bool</entry>
							<entry namest="c2" rowsep='1'>1</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>signed char</entry>
							<entry namest="c2" rowsep='0'>1 to 8</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='1'>unsigned char</entry>
							<entry namest="c2" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>signed short</entry>
							<entry namest="c2" rowsep='0'>1 to 16</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='1'>unsigned short</entry>
							<entry namest="c2" rowsep='1'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>signed int</entry>
							<entry namest="c2" rowsep='0'>1 to 32</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>signed long</entry>
							<entry namest="c2" rowsep='0'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>unsigned int</entry>
							<entry namest="c2" rowsep='0'></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>unsigned long</entry>
							<entry namest="c2" rowsep='0'></entry>
						</row>
						<row rowsep='1'>
							<entry namest="c1">enum</entry>
							<entry namest="c2"></entry>
						</row>
						<row rowsep='0'>
							<entry namest="c1" rowsep='0'>signed long long</entry>
							<entry namest="c2" rowsep='0'>1 to 64</entry>
						</row>
						<row rowsep='1'>
							<entry namest="c1">unsigned long long</entry>
							<entry namest="c2"></entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>Bit-fields can be signed or unsigned of type short, int, long, or long long.
			However, bit-fields shall have the same range for each corresponding type;
			for example, signed short must have the same range as unsigned short. All
			members of structures and unions must comply with the size and alignment
			rules including bit-fields.  The following list of size and alignment
			rules additionally apply to bit-fields:</para>

			<itemizedlist>
				<listitem>

					<para>The allocation of bit-fields is determined by the system endianess.  For
					little-endian implementations the bit allocation is from the least significant
					(right) end to the most significant (left) end.  The reverse is true for
					big-endian implementations; the bit allocation is from most significant (left)
					end to the least significant (right) end.</para>

				</listitem>
				<listitem>
					<para>A bit-field cannot cross its unit boundary; it must occupy the storage unit
					allocated for its declared type.  </para>
				</listitem>
				<listitem>
					<para>If there is enough space within a storage unit, bit-fields
					must share the storage unit with other structure members, including members
					that are not bit-fields.  Clearly all the structure members occupy
					different parts of the storage unit.</para>
				</listitem>
				<listitem>
					<para>The types of unnamed bit-fields have no effect on the
					alignment of a structure or union.  However the offsets of an
					individual bit-field's member must comply with the alignment
					rules.  An unnamed bit-field of zero
					width causes sufficient padding (possibly none) to be inserted for
					the next member, or the end of the structure if there are no more
					nonzero width members, to have an offset from the start of the
					structure that is a multiple of the size of the declared type of the
					zero-width member.</para>
				</listitem>
			</itemizedlist>

			<para>The byte offsets for structure and union members are shown in the
			examples below.  The little-endian byte offsets are given in the upper
			right corners, and the big-endian byte offsets are given in the upper
			left corners.  The bit numbers are given in the lower corners.</para>

			<table frame="all"><title>Bit Numbering for 0x01020304</title>
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">3</entry>
						<entry namest="c3">1</entry>
						<entry namest="c4">2</entry>
						<entry namest="c5">2</entry>
						<entry namest="c6">1</entry>
						<entry namest="c7">3</entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>01</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>02</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>03</entry>
						<entry namest="c7" nameend="c8" align="center">04</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
				</tbody>
				</tgroup>
			</table>

			<figure><title>Simple Bit-field Allocation</title>
				<programlisting>
struct {
  int j : 5;
  int k : 6;
  int m : 7;
};
				</programlisting>
				<synopsis>word-aligned, sizeof is 4</synopsis>
			</figure>

			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1"></entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5"></entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>pad</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>m</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>k</entry>
						<entry namest="c7" nameend="c8" align="center">j</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">13</entry>
						<entry namest="c3">14</entry>
						<entry namest="c4">20</entry>
						<entry namest="c5">21</entry>
						<entry namest="c6">26</entry>
						<entry namest="c7">27</entry>
						<entry namest="c8">31</entry>
					</row>
				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5"></entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>j</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>k</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>m</entry>
						<entry namest="c7" nameend="c8" align="center">pad</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">4</entry>
						<entry namest="c3">5</entry>
						<entry namest="c4">10</entry>
						<entry namest="c5">11</entry>
						<entry namest="c6">17</entry>
						<entry namest="c7">18</entry>
						<entry namest="c8">31</entry>
					</row>
				</tbody>
				</tgroup>
			</informaltable>


			<figure><title>Bit-Field Allocation With Boundary Alignment</title>
				<programlisting>
struct {
  short s : 9;
  int   j : 9;
  char  c;
  short t : 9;
  short u : 9;
  char  d;
};
				</programlisting>
				<synopsis>word-aligned, sizeof is 12</synopsis>
			</figure>


			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">3</entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5"></entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>c</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>pad</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>j</entry>
						<entry namest="c7" nameend="c8" align="center">s</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">13</entry>
						<entry namest="c5">14</entry>
						<entry namest="c6">22</entry>
						<entry namest="c7">23</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1"></entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5"></entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8">5</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>pad</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>u</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>pad</entry>
						<entry namest="c7" nameend="c8" align="center">t</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">6</entry>
						<entry namest="c3">7</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">22</entry>
						<entry namest="c7">23</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c6" align="right" colsep="1">9</entry>
						<entry namest="c7"></entry>
						<entry namest="c8">8</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c6" align="center" colsep='1'>pad</entry>
						<entry namest="c7" nameend="c8" align="center">d</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1" nameend="c5">0</entry>
						<entry namest="c6" colsep='1' align="right">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>


				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5"></entry>
						<entry namest="c6"></entry>
						<entry namest="c7">3</entry>
						<entry namest="c8"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>s</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>j</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>pad</entry>
						<entry namest="c7" nameend="c8" align="center">c</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">8</entry>
						<entry namest="c3">9</entry>
						<entry namest="c4">17</entry>
						<entry namest="c5">18</entry>
						<entry namest="c6">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1">4</entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5">6</entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>t</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>pad</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>u</entry>
						<entry namest="c7" nameend="c8" align="center">pad</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">8</entry>
						<entry namest="c3">9</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">24</entry>
						<entry namest="c7">25</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1">8</entry>
						<entry namest="c2" colsep="1"></entry>
						<entry namest="c3" nameend="c8" align="left">9</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>d</entry>
						<entry namest="c3" nameend="c8" align="center">pad</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2" colsep='1' align="right">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c8">31</entry>
					</row>


				</tbody>
				</tgroup>
			</informaltable>


			<figure><title>Bit-Field Allocation With Storage Unit Sharing</title>
				<programlisting>
struct {
  char  c;
  short s : 8;
};
				</programlisting>
				<synopsis>halfword-aligned, sizeof is 2</synopsis>
			</figure>
			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='4' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<tbody>
					<row>
						<entry namest="c1"></entry>
						<entry namest="c2">1</entry>
						<entry namest="c3"></entry>
						<entry namest="c4">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>s</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>c</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>
				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='4' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2"></entry>
						<entry namest="c3">1</entry>
						<entry namest="c4"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>c</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>s</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>
				</tbody>
				</tgroup>
			</informaltable>

			<figure><title>Bit-Field Allocation In A Union</title>
				<programlisting>
union {
  char  c;
  short s : 8;
};
				</programlisting>
				<synopsis>halfword-aligned, sizeof is 2</synopsis>
			</figure>

			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='4' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<tbody>
					<row>
						<entry namest="c1"></entry>
						<entry namest="c2">1</entry>
						<entry namest="c3"></entry>
						<entry namest="c4">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>pad</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>c</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>
					<row>
						<entry namest="c1"></entry>
						<entry namest="c2">1</entry>
						<entry namest="c3"></entry>
						<entry namest="c4">0</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>pad</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>s</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>

				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='4' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2"></entry>
						<entry namest="c3">1</entry>
						<entry namest="c4"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>c</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>pad</entry>
					</row>	
					<row rowsep="1">
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2"></entry>
						<entry namest="c3">1</entry>
						<entry namest="c4"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>s</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>pad</entry>
					</row>	
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
					</row>

				</tbody>
				</tgroup>
			</informaltable>

			<figure id="UNNAMED-BIT-FIELDS"><title>Bit-Field Allocation With Unnamed Bit-Fields</title>
				<programlisting>
struct {
  char  c;
  int   : 0;
  char  d;
  short : 9;
  char  e;
};
				</programlisting>
				<synopsis>byte aligned, sizeof is 9</synopsis>
			</figure>

			<para>little-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1" nameend="c6" colsep="1" align="right">1</entry>
						<entry namest="c8">0</entry>
					</row>
					<row>
						<entry namest="c1"  nameend="c6" colsep="1" align="center">:0</entry>
						<entry namest="c7" nameend="c8" align="center">c</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2" nameend="c6" colsep="1" align="right">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1"></entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4">6</entry>
						<entry namest="c5"></entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8">4</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>pad</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>:9</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>pad</entry>
						<entry namest="c7" nameend="c8" align="center">d</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">6</entry>
						<entry namest="c3">7</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">23</entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c6" align="right" colsep="1"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8">8</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c6" align="center" colsep='1'></entry>
						<entry namest="c7" nameend="c8" align="center">e</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1" nameend="c5"></entry>
						<entry namest="c6" colsep='1' align="right"></entry>
						<entry namest="c7">24</entry>
						<entry namest="c8">31</entry>
					</row>


				</tbody>
				</tgroup>
			</informaltable>

			<para>big-endian</para>
			<informaltable frame="all">
				<tgroup cols='8' colsep='0' rowsep='0'>
				<colspec colwidth="25" colname='c1' align="left">
				<colspec colwidth="25" colname='c2' align="right" colsep='1'>
				<colspec colwidth="25" colname='c3' align="left">
				<colspec colwidth="25" colname='c4' align="right" colsep='1'>
				<colspec colwidth="25" colname='c5' align="left">
				<colspec colwidth="25" colname='c6' align="right" colsep='1'>
				<colspec colwidth="25" colname='c7' align="left">
				<colspec colwidth="25" colname='c8' align="right">
				<tbody>
					<row>
						<entry namest="c1">0</entry>
						<entry namest="c2"></entry>
						<entry namest="c3" nameend="c8">1</entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>c</entry>
						<entry namest="c3" nameend="c8" align="center" colsep='1'>:0</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3" nameend="c7">8</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1">4</entry>
						<entry namest="c2"></entry>
						<entry namest="c3"></entry>
						<entry namest="c4"></entry>
						<entry namest="c5">6</entry>
						<entry namest="c6"></entry>
						<entry namest="c7"></entry>
						<entry namest="c8"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>d</entry>
						<entry namest="c3" nameend="c4" align="center" colsep='1'>pad</entry>
						<entry namest="c5" nameend="c6" align="center" colsep='1'>:9</entry>
						<entry namest="c7" nameend="c8" align="center">pad</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2">7</entry>
						<entry namest="c3">8</entry>
						<entry namest="c4">15</entry>
						<entry namest="c5">16</entry>
						<entry namest="c6">24</entry>
						<entry namest="c7">25</entry>
						<entry namest="c8">31</entry>
					</row>
					<row>
						<entry namest="c1">8</entry>
						<entry namest="c2" colsep="1"></entry>
						<entry namest="c3" nameend="c8" align="left"></entry>
					</row>
					<row>
						<entry namest="c1" nameend="c2" align="center" colsep='1'>e</entry>
					</row>	
					<row rowsep='1'>
						<entry namest="c1">0</entry>
						<entry namest="c2" colsep='1' align="right">7</entry>
					</row>


				</tbody>
				</tgroup>
			</informaltable>


			<note><title>Note</title>
				<para>Note: In <emphasis><xref linkend="UNNAMED-BIT-FIELDS"></emphasis> the alignment of the structure is not
				affected by the unnamed short and int fields.  The named members are
				aligned relative to the start of the structure.  However, it is possible
				that the alignment of the named members is not on optimum boundaries
				in memory.  For instance, in an array of the structure in <emphasis><xref linkend="UNNAMED-BIT-FIELDS"></emphasis>, the <emphasis>d</emphasis> members will not all be on 4-byte (integer) boundaries.</para>
			</note>
		</sect3>
	</sect2>
	</sect1>
	<sect1 id="FUNC-CALL"><title>Function Calling Sequence</title>

		<para>The standard sequence for function calls is outlined in this section.  The layout of the stack
		frame, the parameter passing convention, and the register usage is also detailed in this section.
		Standard library functions use these conventions, except as documented for the register save and restore
		functions.</para>

		<para>The conventions given in this chapter are adhered to by C programs.
		Further information on the implementation of C is given in <emphasis><xref linkend="CODE-EX"></emphasis>.</para>

		<note><title>Note</title> 
			<para>Note: While it is recommended that all functions use the standard
			calling sequence, the requirements of the standard calling sequence are
			only applicable to global functions.  Different calling sequences and
			conventions can be employed by local functions which cannot be reached
			from other compilation units, if they comply with the stack back
			trace requirements.</para>
		</note>

		<note CONDITION="ATR-LONG-DOUBLE-IS-DOUBLE"><title>Note</title>
		<para>Note: If long double has the same representation as double, then all
		statements about how double values are passed to and returned from
		functions also apply to long double, and all statements about how _Complex
		double values are passed to and returned from functions also apply to
		_Complex long double.</para></note>

		<note CONDITION="ATR-PASS-COMPLEX-AS-STRUCT"><title>Note</title>
		<para>Note: For the purposes of the function calling sequence, the C99 _Complex types are treated as if they were represented as a structure containing an array of size two of the corresponding floating point types.  That is, a _Complex float is passed to a function and returned from a function as if it were represented as:</para>

		<programlisting>
struct
  {
    float real[2];
  };</programlisting>

		</note>

		<sect2 id="REG"><title>Registers</title>

			<para>Programs and compilers may freely use all registers except those
			reserved for system use. The system signal handlers are responsible for
			preserving the original values upon return to the original execution
			path.  Signals that can interrupt the original execution path are
			documented in (BA-OS) in the System V Interface Definition.</para>
			<para>The tables in <emphasis><xref linkend="REGISTER-ROLES"></emphasis> give an overview of the registers that are global during program
			execution.  The tables use three terms to describe register
			<emphasis>Preservation Rules</emphasis>:</para>

			<variablelist>

				<varlistentry>
					<term><emphasis role="bold">nonvolatile</emphasis></term>
					<listitem>

						<para>A <emphasis>caller</emphasis> can expect that the contents of all
						registers marked <emphasis>nonvolatile</emphasis> are
						valid after control returns from a function call.</para>

						<para>A <emphasis>callee</emphasis> shall save the contents of all
						registers marked <emphasis>nonvolatile</emphasis> prior to
						modification.  The callee must restore the contents of all such
						registers before returning to its caller.</para>

					</listitem>
				</varlistentry>

				<varlistentry>
					<term><emphasis role="bold">volatile</emphasis></term>
					<listitem>

						<para>A <emphasis>caller</emphasis> cannot trust that the contents of
						registers marked <emphasis>volatile</emphasis> have been
						preserved across a function call.</para>

						<para>A <emphasis>callee</emphasis> need not save the contents of
						registers marked <emphasis>volatile</emphasis> before modification.</para>

					</listitem>
				</varlistentry>

				<varlistentry>
					<term><emphasis role="bold">limited-access</emphasis></term>
					<listitem>

						<para>The contents of registers marked <emphasis>limited-access</emphasis> have special preservation rules.
						These registers have mutability restricted to certain bit-fields as
						defined by the Power ISA.  The individual bits of
						these bit-fields are defined by this ABI to be
						<emphasis>limited-access</emphasis>.</para>

						<para>Under normal conditions a <emphasis>caller</emphasis> can expect
						that these bits have been preserved across a function call.  Under the
						special conditions, indicated in <emphasis><xref linkend="LIMITED-ACCESS"></emphasis>, a
						<emphasis>caller</emphasis> <emphasis>shall expect</emphasis> that these bit will
						have changed across function calls even if they have not.</para>

						<para>A <emphasis>callee</emphasis> may only permanently modify these
						bits without preserving the state upon entrance to the function if the <emphasis>callee</emphasis>
						satisfies the special conditions indicated in <emphasis><xref
						linkend="LIMITED-ACCESS"></emphasis>; otherwise, these bits must be preserved before
						modification and restored before returning to the caller.</para>

					</listitem>
				</varlistentry>
			</variablelist>

			<sect3 id="REGISTER-ROLES"><title>Register Roles</title>

			<para>In the 32-bit Power Architecture, there are always 32 general-purpose registers, each 32 bits wide.  Throughout this document the symbol r<emphasis>N</emphasis> is used, where <emphasis>N</emphasis> is a register number, to refer to general-purpose register <emphasis>N</emphasis>.</para>
			<table id="REGISTER-ROLES-TABLE" frame="none"><title>Register Roles</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r0</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Optional in function linkage</entry>
						</row>
						<row>
							<entry namest="c1">r1</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">Stack frame pointer</entry>
						</row>
						<row>
							<entry namest="c1">r2</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">See the following table</entry>
						</row>
						<row>
							<entry namest="c1">r3&dash;r6</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Parameter and return value</entry>
						</row>
						<row>
							<entry namest="c1">r7&dash;r10</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Additional function parameters</entry>
						</row>
						<row>
							<entry namest="c1">r11&dash;r12</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Optional in function linkage</entry>
						</row>
						<row>
							<entry namest="c1">r13</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">Small data area pointer</entry>
						</row>
						<row>
							<entry namest="c1">r14&dash;r31</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">Local variables</entry>
						</row>
						<row>
							<entry namest="c1">LR</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Link register</entry>
						</row>
						<row>
							<entry namest="c1">CTR</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Loop count register</entry>
						</row>
						<row>
							<entry namest="c1">XER</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Fixed point exception register</entry>
						</row>
						<row>
							<entry namest="c1">CR0-CR1</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Condition register fields</entry>
						</row>
						<row>
							<entry namest="c1">CR2-CR4</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">Condition register fields</entry>
						</row>
						<row>
							<entry namest="c1">CR5-CR7</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Condition register fields</entry>
						</row>
							
					</tbody>
				</tgroup>
			</table>

			<sidebar><title>Optional Function Linkage</title><para>A function cannot depend on the values
			of those registers optional in the function linkage (r0, r11, and r12) because they may be altered by
			inter-library calls.</para></sidebar>

			<sidebar><title>Stack Frame Pointer</title><para>
			The stack pointer always points to the lowest allocated
			valid stack frame.  It must maintain quadword alignment
			and grow toward the lower addresses.  The contents of
			the word at that address always points to the
			previously allocated stack frame.  A called function is
			permitted to decrement it if required.  See <emphasis><xref
			linkend="DYNAM-STACK"></emphasis> for additional information.</para></sidebar>

			<sidebar><title>Small Data Area Pointer</title><para>Register r13 is the small data area
			pointer.  Process start up code for executables that reference data in the small data area with
			16-bit offset addressing relative to r13 must load the base of the small data area (the value of
			the dynamic linker-defined symbol <varname>_SDA_BASE_</varname>) into r13. Shared objects shall not alter the value in
			r13.  See <phrase CONDITION="ATR-LINUX"><emphasis><xref linkend="SMALL-DATA-AREA"></emphasis></phrase> <phrase CONDITION="ATR-LINUX && ATR-EABI"> and </phrase><phrase CONDITION="ATR-EABI"><emphasis><xref linkend="SMALL-DATA-AREA-E500"></emphasis></phrase> for more details.</para></sidebar>

			<sidebar><title>Link Register</title><para>The link
			register contains the address a called function
			normally returns to.  It is volatile across function
			calls.</para></sidebar>

			<sidebar><title>Condition Register Fields</title><para>In the condition register, the
			bit-fields CR2, CR3, and CR4 are nonvolatile and the value on entry must be restored on exit.
			The other bit-fields are volatile.  The bit-field CR6 shall be set by the caller of a variable
			argument list function as described in <emphasis><xref linkend="VARIABLE-ARG"></emphasis>.</para></sidebar>

			<table id="LINUX-GENERAL-REGISTER2-ROLES-TABLE" frame="none" CONDITION="ATR-LINUX && ATR-TLS"><title>TLS ABI Register Role for General-Purpose Register 2</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r2</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">Thread pointer</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para CONDITION="ATR-EABI">Register r2 shall contain the base of the small data area 2 (the
			value of the dynamic linker-defined symbol <varname>_SDA2_BASE_</varname>) which is used for
			referencing the ELF sections named .PPC.EMB.sdata2 and .PPC.EMB.sbss2, if either section exists
			in an executable.  The small data area 2 base is an address such that every byte in the two
			sections is within a signed 16-bit offset of that address, which is analogous to the use of r13,
			as described previously, to contain <varname>_SDA_BASE_</varname>, which is the base of sections
			.sdata and .sbss. A routine in a shared object shall not use r2. See <emphasis><xref
			linkend="SDATA2-AND-SBSS2-E500"></emphasis> for more details.

			<table id="EABI-GENERAL-REGISTER2-ROLES-TABLE" frame="none"><title>EABI Register Role for General-Purpose Register 2</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r2</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">SDA2 (Small Data Area 2) pointer.</entry>
						</row>
					</tbody>
				</tgroup>
			</table></para>

			<table id="COMPLEX-REGISTER-ROLES-TABLE" frame="none" CONDITION="ATR-PASS-COMPLEX-IN-GPRS"><title>Register Roles for the _Complex float and _Complex double Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r3-r10</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for _Complex float and _Complex double <emphasis>parameters and return values</emphasis>.</entry>
						</row>
					</tbody>
					</tgroup>
					</table>


			<table id="COMPLEX-LD-REGISTER-ROLES-TABLE" frame="none" CONDITION="ATR-PASS-COMPLEX-IN-GPRS && ATR-LONG-DOUBLE-IBM"><title>Register Roles for the _Complex Long Double Type</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r3-r10</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for the _Complex long double <emphasis>parameters and return values</emphasis>.</entry>
						</row>
					</tbody>
					</tgroup>
					</table>


			<para CONDITION="ATR-SECURE-PLT">Under the Secure-PLT ABI, when using the <emphasis><link linkend="ADDRESSING-MODELS">Position-Independent Code</link></emphasis> (PIC) addressing model, register r30 is used (by convention between compiler & link editor) in nonleaf functions to hold the <emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> (GOT) pointer.  See <emphasis><xref linkend="SECURE-PLT"></emphasis> for information on the Secure-PLT.

			<table id="LINUX-GENERAL-REGISTER30-ROLE-TABLE" frame="none"><title>Secure-PLT Register Role for General-Purpose Register 30</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r30</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3">GOT pointer under the Secure-PLT with the Position-Independent Code (PIC) addressing model</entry>
						</row>
								
					</tbody>
				</tgroup>
			</table></para>


			<para CONDITION="ATR-CLASSIC-FLOAT">On Power Architecture processors
			that support Power ISA category <emphasis>Floating-point</emphasis>, there are always 32
			floating-point registers, each 64 bits wide, and an associated special-purpose register to provide floating-point status and control.  Throughout this document the symbol f<emphasis>N</emphasis> is used, where <emphasis>N</emphasis> is a register number, to refer to floating-point register <emphasis>N</emphasis>.

			<table id="FP-REGISTER-ROLES-TABLE" frame="none"><title>Floating-Point Register Roles for Binary Floating-Point Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">f0</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1">f1</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for <emphasis>parameter passing</emphasis> and <emphasis>return values</emphasis> of binary float types.</entry>
						</row>
						<row>
							<entry namest="c1">f2-f8</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for <emphasis>parameter passing</emphasis> of binary float types.</entry>
						</row>
						<row>
							<entry namest="c1">f9-f13</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1">f14-f31</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>FPSCR</entry>
							<entry namest="c2" rowsep='0'>limited-access</entry>
							<entry namest="c3" rowsep='0'>Floating point status and control register limited-access bits.  Preservation rules governing the limited-access bits for the bit-fields [VE], [OE], [UE], [ZE], [XE], and [RN] are presented in <emphasis><xref linkend="LIMITED-ACCESS"></emphasis>.</entry>
						</row>
					</tbody>
					</tgroup>
					</table></para>


			<para CONDITION="ATR-CLASSIC-FLOAT && ATR-DFP">The ISA Decimal Floating-Point category extends the Power Architecture
			by adding a decimal floating-point unit.  It uses the existing 64-bit floating-point registers
			and extends the FPSCR register to 64-bits, where it defines a decimal rounding-control field in
			the extended space.

			<table id="DFP-REGISTER-ROLES-TABLE" frame="none"><title>Floating-Point Register Roles for Decimal Floating-Point Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3">Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">f0</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1">f1</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for <emphasis>parameter passing</emphasis> and <emphasis>return values</emphasis> of <emphasis role="bold">single-precision</emphasis> and <emphasis role="bold">double-precision</emphasis> decimal floating-point types.</entry>
						</row>
						<row>
							<entry namest="c1">f2-f8</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for <emphasis>parameter passing</emphasis> and <emphasis>return values</emphasis> of <emphasis role="bold">quad-precision</emphasis> decimal floating-point types.</entry>
						</row>
						<row>
							<entry namest="c1">f9-f13</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1">f14-f31</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>FPSCR</entry>
							<entry namest="c2" rowsep='0'>limited-access</entry>
							<entry namest="c3" rowsep='0'>Floating point status and control register limited-access bits.  Preservation rules governing the limited-access bits for the bit-field [DRN] are presented in <emphasis><xref linkend="LIMITED-ACCESS"></emphasis>.</entry>

						</row>
					</tbody>
					</tgroup>
					</table></para>

			<table id="SOFT-FP-REGISTER-ROLES-TABLE" frame="none" CONDITION="ATR-SOFT-FLOAT"><title>Soft-Float General-Purpose Register Roles for Binary Floating-Point Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r3-r10</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Volatile parameter and return value registers for float, double, and long double binary floating-point types.</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">If the parameters are within the first eight words of the parameter list:</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">&bull; Float values occupy a single GPR.</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">&bull; Double values occupy adjacent GPRs.</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">&bull; Long double values occupy four adjacent GPRs.</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'></entry>
							<entry namest="c2" rowsep='0'></entry>
							<entry namest="c3" rowsep='0'>There are special rules governing how parameters that span multiple GPRs should be split between registers and the parameter save area outlined in <emphasis><xref linkend="PARAM-PASS"></emphasis>.</entry>
						</row>
					</tbody>
					</tgroup>
					</table>

			<table id="SOFT-DFP-REGISTER-ROLES-TABLE" frame="none" CONDITION="ATR-SOFT-FLOAT && ATR-DFP"><title>Soft-Float General-Purpose Register Roles for Decimal Floating-Point Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">r3-r10</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Volatile parameter and return value registers for _Decimal32, _Decimal64, and _Decimal128 Decimal floating-point types</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">If the parameters are within the first eight words of the parameter list:</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">&bull; _Decimal32 values occupy a single GPR.</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">&bull; _Decimal64 values occupy adjacent GPRs.</entry>
						</row>
						<row>
							<entry namest="c1"></entry>
							<entry namest="c2"></entry>
							<entry namest="c3">&bull; _Decimal128 values occupy four adjacent GPRs.</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'></entry>
							<entry namest="c2" rowsep='0'></entry>
							<entry namest="c3" rowsep='0'>There are special rules governing how parameters that span multiple GPRs should be split between registers and the parameter save area outlined in <emphasis><xref linkend="PARAM-PASS"></emphasis>.</entry>
						</row>
						</tbody>
					</tgroup>
					</table>


			<para CONDITION="ATR-VECTOR">The ISA Vector category extends the Power
			Architecture and provides 32 vector registers, each 128 bits wide, a
			special-purpose register VRSAVE, and a special-purpose register VSCR. Throughout this document the symbol v<emphasis>N</emphasis> is used, where <emphasis>N</emphasis> is a register number, to refer to vector register <emphasis>N</emphasis>.

			<table id="VR-REGISTER-ROLES-TABLE" frame="none"><title>Vector Register Roles</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">v0-v1</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1">v2</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for <emphasis>parameter passing</emphasis> and <emphasis>return values</emphasis></entry>
						</row>
						<row>
							<entry namest="c1">v3-v13</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3">Used for <emphasis>parameter passing</emphasis></entry>
						</row>
						<row>
							<entry namest="c1">v14-v19</entry>
							<entry namest="c2">volatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1">v20-v31</entry>
							<entry namest="c2">nonvolatile</entry>
							<entry namest="c3"></entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>VRSAVE</entry>
							<entry namest="c2" rowsep='0'>nonvolatile</entry>
							<entry namest="c3" rowsep='0'>32-bit VR Save Register.</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>VSCR</entry>
							<entry namest="c2" rowsep='0'>limited-access</entry>
							<entry namest="c3" rowsep='0'>32-bit vector status and control register.  Preservation rules governing the limited-access bits for the bit-field [NJ] are presented in <emphasis><xref linkend="LIMITED-ACCESS"></emphasis>.</entry>
						</row>
					</tbody>
					</tgroup>
					</table></para>

			<para CONDITION="ATR-VECTOR-SCALAR">The ISA Vector Scalar (VSX) category provides upper doublewords
			for the 32 floating-point registers, thus allowing them to be used as vector registers.  These new
			vector registers are mapped to registers 0 to 31 in the VSX registers file, and their lower
			doublewords correspond to floating-point registers 0 to 31.  The 32 registers from the Vector
			category are mapped to registers 32 to 63 in the VSX registers file.  Throughout this document
			the symbol vs<emphasis>N</emphasis> is used, where <emphasis>N</emphasis> is a register number,
			to refer to vector scalar register <emphasis>N</emphasis>.  VSX registers from 0 to 31 are volatile,
			but before using registers from the vs14-vs31 interval their corresponding floating-point registers
			need to be saved in the stack, since they are nonvolatile.  VSX registers from 32-63 retain their
			volatility and purpose set forth in <emphasis><xref linkend="VR-REGISTER-ROLES-TABLE"></emphasis>.</para>

			<para CONDITION="ATR-SPE">The ISA Signal Processing Engine (SPE) category provides upper words
			for the 32 general-purpose registers, thus allowing them to be used in SPE APU operations to
			hold two 32-bit words.  The Signal Processing Engine category also provides several
			special-purpose registers. The volatility of all 64-bit registers is the same for the upper and
			lower word. If only the lower word is modified by a function, only the lower word need be saved
			and restored.

			<table id="SPE-REGISTER-ROLES-TABLE" frame="none"><title>SPE Register Roles</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='100' colname='c2' align="left">
					<colspec colwidth='220' colname='c3' align="left">
					<thead>
						<row>
							<entry namest="c1" rowsep='1'>Register</entry>
							<entry namest="c2" rowsep='1'>Preservation Rules</entry>
							<entry namest="c3" rowsep='1'>Purpose</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry namest="c1">SPEFSCR</entry>
							<entry namest="c2">limited-access</entry>
							<entry namest="c3">Signal processing and embedded floating-point status and control register.  Preservation rules governing the limited-access bits for the bit-fields [FINXE], [FINVE], [FDBZE], [FUNFE], [FOVFE], and [FRMC] are presented in <emphasis><xref linkend="LIMITED-ACCESS"></emphasis>.</entry>
						</row>
						<row>
							<entry namest="c1" rowsep='0'>ACC</entry>
							<entry namest="c2" rowsep='0'>volatile</entry>
							<entry namest="c3" rowsep='0'>64-bit SPE accumulator register.</entry>
						</row>
					</tbody>
					</tgroup>
					</table></para>
			</sect3> <!-- /REGISTER-ROLES -->
			<sect3 id="LIMITED-ACCESS"><title>Limited-Access Bits</title>

			<para>The Power ISA identifies a number of registers which have mutability limited to the specific bit-fields indicated in the following list:</para>

			<variablelist>
				<varlistentry CONDITION="ATR-CLASSIC-FLOAT"><term>FPSCR [VE]</term>
					<listitem>
						<para>The <emphasis>Floating-Point Invalid Operation Exception Enable</emphasis> bit
						[VE] of the FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-CLASSIC-FLOAT"><term>FPSCR [OE]</term>
					<listitem>
						<para>The <emphasis>Floating-Point Overflow Exception Enable</emphasis> bit
						[OE] of the FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-CLASSIC-FLOAT"><term>FPSCR [UE]</term>
					<listitem>
						<para>The <emphasis>Floating-Point Underflow Exception Enable</emphasis> bit
						[UE] of the FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-CLASSIC-FLOAT"><term>FPSCR [ZE]</term>
					<listitem>
						<para>The <emphasis>Floating-Point Zero Divide Exception Enable</emphasis> bit
						[ZE] of the FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-CLASSIC-FLOAT"><term>FPSCR [XE]</term>
					<listitem>
						<para>The <emphasis>Floating-Point Inexact Exception Enable</emphasis> bit
						[XE] of the FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-CLASSIC-FLOAT"><term>FPSCR [RN]</term>
					<listitem>
						<para>The <emphasis>Binary Floating-Point Rounding
						Control</emphasis> field [RN] of the FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-DFP"><term>FPSCR [DRN]</term>
					<listitem>
						<para>The <emphasis>DFP Rounding Control</emphasis> field [DRN] of the 64-bit FPSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-VECTOR"><term>VSCR [NJ]</term>
					<listitem>
						<para>The <emphasis>Vector Non-Java Mode</emphasis> field [NJ] of the
						VSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-SPE"><term>SPEFSCR [FINXE]</term>
					<listitem>
						<para>The <emphasis>Embedded Floating-Point Round (Inexact)
						Exception Enable</emphasis> field [FINXE] of the SPEFSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-SPE"><term>SPEFSCR [FINVE]</term>
					<listitem>
						<para>The <emphasis>Embedded Floating-Point Invalid
						Operation/Input Error Exception Enable</emphasis> field [FINVE] of the SPEFSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-SPE"><term>SPEFSCR [FDBZE]</term>
					<listitem>
						<para>The <emphasis>Embedded Floating-Point Divide By Zero
						Exception Enable</emphasis> field [FDBZE] of the SPEFSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-SPE"><term>SPEFSCR [FUNFE]</term>
					<listitem>
						<para>The <emphasis>Embedded Floating-Point Underflow
						Exception Enable</emphasis> field [FUNFE] of the SPEFSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-SPE"><term>SPEFSCR [FOVFE]</term>
					<listitem>
						<para>The <emphasis>Embedded Floating-Point Overflow
						Exception Enable</emphasis> field [FOVFE] of the SPEFSCR register.</para>
					</listitem>
				</varlistentry>
				<varlistentry CONDITION="ATR-SPE"><term>SPEFSCR [FRMC]</term>
					<listitem>
						<para>The <emphasis>Embedded Floating-Point Rounding Mode
						Control</emphasis> field [FRMC] of the SPEFSCR register.</para>
					</listitem>
				</varlistentry>
			</variablelist>


			<para>The bits composing these bit-fields are identified as
			<emphasis>limited-access</emphasis> because this ABI manages how they are to be modified and
			preserved across function calls.</para>

			<para><emphasis>Limited-access</emphasis> bits may be changed across function calls only if
			the called function has specific permission to do so as indicated by the following conditions.</para>

			<para>A function without permission to change the <emphasis>limited-access</emphasis> bits
			across a function call shall save the value of the register before modifying the bits and restore
			it before returning to its calling function.</para>

			<itemizedlist>
				<title>Limited-Access Conditions</title>
				<listitem>
					<para>Standard library functions expressly defined to change the
					state of limited-access bits are not constrained by nonvolatile
					preservation rules, e.g., the <varname>fesetround()</varname> and <varname>feenableexcept()</varname> functions.</para>
				</listitem>
				<listitem>
					<para>All other standard library functions shall save the old
					value of these bits on entry, change the bits for their purpose, and restore
					the bits before returning.</para>
				</listitem>
				<listitem>
					<para>Where a standard library function such as <varname>qsort()</varname> calls
					functions provided by an application the following rules shall be observed:</para>
					<itemizedlist>

						<listitem><para>The limited-access bits on entry to the first call
						to such a callback must have the values they had on entry to the
						library function.  </para></listitem>

						<listitem><para>The limited-access bits on entry to a subsequent
						call to such a callback must have the values they had on exit from
						the previous call to such a callback.  </para></listitem>

						<listitem><para>The limited-access bits on exit from the library
						function must have the values they had on exit from the last call
						to such a callback.  </para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>The compiler can directly generate code that saves and
					restores the limited-access bits.</para>
				</listitem>
				<listitem>

					<para>The values of the limited-access bits are unspecified on entry into a
					signal handler because a library or user function can temporarily modify
					the limited-access bits when the signal was taken.  </para>

				</listitem>
				<listitem>
					<para>When <varname>setjmp()</varname> returns from a direct invocation, the
					limited-access bits must have the values they had on entry to
					setjmp; when it returns from a call to <varname>longjmp()</varname>, the limited-access
					bits must have the values they had on entry to <varname>longjmp()</varname>.</para>
				</listitem>
				<listitem CONDITION="ATR-CLASSIC-FLOAT">
					<para>C Library intrinsics, such as <varname>_FPU_SETCW()</varname>, may modify the
					limited-access bits of the FPSCR.</para>
				</listitem>
				<listitem CONDITION="ATR-VECTOR">
					<para>The ALTIVEC PIM <varname>vec_mtvscr()</varname> intrinsic may change the
					limited-access NJ bit.</para>
				</listitem>
				<listitem CONDITION="ATR-SPE">
					<para>The following intrinsics defined by the SPE PIM may change the
					limited-access bits of the SPEFCSR register:</para>
					<para><varname>__ev_clr_spefscr_sovh()</varname>
					<varname>__ev_clr_spefscr_sov()</varname> <varname>__ev_clr_spefscr_finxs()</varname> <varname>__ev_clr_spefscr_finvs()</varname>
					<varname>__ev_clr_spefscr_fdbzs()</varname> <varname>__ev_clr_spefscr_funfs()</varname> <varname>__ev_clr_spefscr_fovfs()</varname>
					<varname>__ev_set_spefscr_frmc()</varname></para>
				</listitem>
				<listitem CONDITION="ATR-SOFT-FLOAT">
					<para>Any data stored internally by software floating-point code to
					describe rounding modes and enabled exceptions is subject to the
					same rules as limited-access register bits.</para>
				</listitem>
			</itemizedlist>

			<note><title>Note</title><para>Note: The unwinder does not need to make
			specific allowances for limited-access bits.</para></note></sect3>
		</sect2>

		<sect2 id="STACK"><title>The Stack Frame</title>

			<para>A function shall establish a stack frame if it requires the use of nonvolatile
			registers, its local variable usage can't be optimized into registers, or it calls another
			function.  It need only allocate space for the required stack frame elements, namely the
			<emphasis>backchain pointer</emphasis>, the <emphasis>LR save area</emphasis>, and
			<emphasis>padding</emphasis> to the required alignment.</para>

			<para><xref linkend="SFO"> shows the relative layout of an allocated stack frame following a nonleaf function call, where the
			<emphasis>stack pointer</emphasis> points to the <emphasis>backchain</emphasis> word of the caller's stack frame.  In general the <emphasis>stack
			pointer</emphasis> always points to the <emphasis>backchain</emphasis> word of the most
			recently allocated stack frame.  </para>

			<figure ID="SFO"><title>Stack Frame Organization</title>
			<mediaobject><imageobject><imagedata scale=75 fileref="graphics/StackFrame.png" format="PNG"></imageobject>

			<caption><para>In <xref linkend="SFO"> the green areas indicate an <emphasis>optional</emphasis> save area of the stack frame.  Refer to <emphasis><xref linkend="SAVE-AREAS"></emphasis> for a description of the optional save areas described by this ABI.</para></caption>
			</mediaobject>
			</figure>

			<!--<figure ID="ZZZ"><title>Stack Frame Organization</title>
			<mediaobject><imageobject><imagedata fileref="graphics/StackFrame.svg" format="SVG"></imageobject></mediaobject>
			</figure> -->

			<sect3 id="STACK-REQS"><title>General Stack Frame Requirements</title>
				<para>The following general requirements apply to all stack frames:</para>
				<itemizedlist>
					<listitem>
						<para>The stack shall be quadword-aligned.</para>
					</listitem>
					<listitem>
						<para>The minimum stack frame size shall be 16 bytes. A minimum stack frame consists of the
						first two words (<emphasis>backchain</emphasis> word and
						<emphasis>LR save word</emphasis>), with
							padding to meet the 16-byte alignment requirement.</para>
	
					</listitem>
	
					<listitem>
						<para>There is no maximum stack frame defined.</para>
					</listitem>
	
					<listitem><para>Padding shall be added to the <emphasis>local variable
					space</emphasis> of the
					stack frame to maintain the defined stack frame alignment in
					the absence of register save areas.</para>
					</listitem>
	
					<listitem>
						<para>The <emphasis>stack pointer</emphasis> (r1), shall always point to the lowest address word of the most recently allocated stack frame.</para>


					</listitem>
	
					<listitem>
						<para>The stack shall start at high addresses and grow downward
						toward lower addresses.</para>
					</listitem>

					<listitem>
						<para>The lowest address word (the <emphasis>backchain</emphasis> word in <xref linkend="SFO">)
						shall point to the previously allocated stack frame. An exception
						occurs with the first stack frame, which shall have a value of 0
						(NULL).</para>
					</listitem>
	
					<listitem>
						<para>If required, the stack pointer shall be decremented in the
						called function's prologue and restored in the called function's
						epilogue.</para>
					</listitem>
	
					<listitem>
						<para>The <emphasis>stack pointer shall be updated atomically</emphasis> so
						that, at all times, it points to a valid <emphasis>backchain</emphasis> word.
						This update may be achieved in a number of ways, as indicated in <emphasis><xref linkend="PRO-EP-RULES"></emphasis>.</para> </listitem>
					<listitem>
						<para>Before a function calls any other functions, it shall save the
						value of the LR register into the <emphasis>LR save area</emphasis> of
						the caller's stack frame.</para>
					</listitem>
				</itemizedlist>

				<note><title>note</title><para>Note: An optional frame pointer may
				be created if necessary (e.g., as a result of dynamic allocation on the stack as
				described in <emphasis><xref linkend="DYNAM-STACK"></emphasis>) to address arguments or local
				variables.</para></note>

				<para>A sample of a minimum stack frame allocation is demonstrated
				in <emphasis><xref linkend="MIN-STACK"></emphasis> containing these requirements.</para>

				<figure ID="MIN-STACK"><title>Example Minimum Stack Frame Allocation</title>
					<screen>
stwu 1,&minus;32(1)      - Store backchain, decr SP
mflr 0             - Copy LR to R0
stw  0,36(1)       - Store LR in previous LR save area</screen>
				</figure>
			</sect3>
			<sect3 id="SAVE-AREAS">
				<title>Optional Save Areas</title>

				<para>This ABI provides a stack frame with a number of optional save areas.  This
				section will indicate the relative position of these save areas in relation to each
				other and the primary elements of the stack frame.</para>

				<para>Because the back chain word of a stack frame must maintain quadword alignment the following save area diagrams indicate that an optional <emphasis>special purpose padding</emphasis> element might be necessary near the low-address end of a stack frame (above the link register save).</para>

<!--			<itemizedlist>
				<listitem CONDITION="ATR-VECTOR"><para>A single word of padding can be necessary before the
				<emphasis>vector save area</emphasis> in order to maintain the required stack frame alignment.</para></listitem>

				<listitem CONDITION="ATR-SPE"><para>A single word of padding can be necessary above the low-address end the <emphasis>64-bit general
				register save area</emphasis> in order to maintain the required stack frame
				alignment.</para></listitem>

				<listitem><para>A single word of padding can be necessary before the <emphasis>general
				register save area</emphasis> in order to maintain the required stack frame
				alignment<phrase CONDITION="ATR-VECTOR"> in the case where the
				<emphasis>vector save area</emphasis> is unused</phrase>.</para></listitem>
			</itemizedlist></para> -->

				<para>An optional <emphasis>alignment padding to quadword boundary</emphasis> element might be necessary near the high-address end of the stack in order to quadword-align the low-address beginning of a register save area immediately below it, e.g, <emphasis><xref linkend="FIG-SPE-SAVE-AREA"></emphasis>.</para>

				<variablelist id="REGISTER-SAVE-AREAS">
					<title>Register Save Areas</title>

					<varlistentry id="FPR-SAVE-AREA" CONDITION="ATR-CLASSIC-FLOAT">
						<term><emphasis role="bold">Floating-Point Register Save Area</emphasis></term>
						<listitem>
							<para>If a function is to change the value in any nonvolatile
							floating-point register fr<emphasis>n</emphasis> it shall first save the value fr<emphasis>n</emphasis>
							in the <emphasis>Floating-Point Register Save Area</emphasis> in
							a doubleword located 8 &times; (32 &minus; <emphasis>n</emphasis>) bytes before the back
							chain word of the previous frame, as shown in <emphasis><xref linkend="FIG-FPR-AND-GPR-SAVE-AREAS"></emphasis>.</para>
							<figure ID="FIG-FPR-AND-GPR-SAVE-AREAS">
								<title>General-Purpose and Floating-Point Register Save Areas</title>
								<mediaobject><imageobject><imagedata scale=62 fileref="graphics/FPR-and-GPR-SaveArea.png" format="PNG"></imageobject></mediaobject></figure>
						</listitem>
					</varlistentry>
					<varlistentry id="GPR-SAVE-AREA-WITH-FP" CONDITION="ATR-CLASSIC-FLOAT">
						<term><emphasis role="bold">General-Purpose Register Save Area (with floating-point registers available)</emphasis></term>
						<listitem>

							<para>If a function is to change the value in any nonvolatile
							general-purpose register r<emphasis>n</emphasis>, it shall first save the value of
							r<emphasis>n</emphasis> in the <emphasis>general register save area</emphasis>, in a
							word located 4 &times; (32 &minus; <emphasis>n</emphasis>) bytes before the low-addressed
							end of the <emphasis>Floating-Point Register Save
							Area</emphasis>, as shown in <emphasis><xref linkend="FIG-FPR-AND-GPR-SAVE-AREAS"></emphasis>.</para>

						</listitem>
	
					</varlistentry>
					<varlistentry id="GPR-SAVE-AREA" CONDITION="!ATR-CLASSIC-FLOAT">
						<term><emphasis role="bold">General-Purpose Register Save Area</emphasis></term>
						<listitem>

							<para>If a function is to change the value in any nonvolatile
							general-purpose register r<emphasis>n</emphasis>, it shall first save the value of
							r<emphasis>n</emphasis> in the <emphasis>General-Purpose Register Save Area</emphasis>, in a
							word located 4 &times; (32 &minus; <emphasis>n</emphasis>) bytes before the backchain
							word of the previous frame, as shown in <emphasis><xref linkend="FIG-GPR-SAVE-AREA"></emphasis>.</para>

							<figure ID="FIG-GPR-SAVE-AREA">
								<title>General-Purpose Register Save Area</title>
								<mediaobject><imageobject><imagedata scale=62 fileref="graphics/GPR-SaveArea.png" format="PNG"></imageobject></mediaobject>
							</figure>

						</listitem>
					</varlistentry>
				</variablelist>

				<variablelist id="CR-SAVE-AREA">
					<title>CR Save Area</title>
					<varlistentry id="CR-SAVE-REGISTER-SAVE-AREA">
						<term><emphasis role="bold">CR Save-Register Save Area</emphasis></term>
						<listitem>
							<para>If a function changes the value in any nonvolatile field
							of the condition register, it shall first save the value in all
							the nonvolatile fields of the condition register in the
							<emphasis>CR Save Area</emphasis>, which is the word below the
							low address end of the <emphasis>general register save
							area</emphasis>, as shown in <xref linkend="FIG-CR-SAVE-AREA">.</para>

							<figure ID="FIG-CR-SAVE-AREA">
								<title>CR Save Area</title>
								<mediaobject><imageobject><imagedata scale=62 fileref="graphics/CR-SaveArea.png" format="PNG"></imageobject></mediaobject></figure>


							<figure ID="FIG-CR-SAVE-AREA-FP" CONDITION="ATR-CLASSIC-FLOAT">
								<title>CR Save Area With Floating-Point Save Area</title>
								<mediaobject><imageobject><imagedata scale=62 fileref="graphics/CR-SaveArea-FP.png" format="PNG"></imageobject>
									<caption><para><emphasis><xref linkend="FIG-CR-SAVE-AREA-FP"></emphasis> shows the location of the CR save area when a floating-point save area is present.</para></caption></mediaobject></figure>


						</listitem>
					</varlistentry>
				</variablelist>
		
				<variablelist id="CATEGORY-SPECIFIC-SAVE-REGISTER-SAVE-AREA">
					<title>Category Specific Save-Register Save Area</title>
					<varlistentry id="NOT-VR-SAVE-REGISTER-SAVE-AREA" CONDITION="!ATR-VECTOR">
						<term>The category-specific save-register save area is unnecessary.</term>
						<listitem><para></para></listitem>
					</varlistentry>
					<varlistentry id="VR-SAVE-REGISTER-SAVE-AREA" CONDITION="ATR-VECTOR">
						<term><emphasis role="bold">VRSAVE Register Save Area</emphasis></term>
						<listitem>

							<para>Functions must ensure that the appropriate bits in the
							VRSAVE register are set for any vector registers they use.  A
							function that changes the value of the VRSAVE register shall
							save the original value of VRSAVE into the <emphasis>VRSAVE save
							area</emphasis>.  If the CR save area is present, the <emphasis>VRSAVE
							save area</emphasis> is located in the word below the <emphasis>CR save area</emphasis>.
							Otherwise, the <emphasis>VRSAVE save area</emphasis> is located in the word below the
							low address end of the <emphasis>general register save
							area</emphasis>.  Both options are shown in <xref
							linkend="FIG-VR-SAVE-AREAS">.</para>


						</listitem>

					</varlistentry>
				</variablelist>

				<figure ID="FIG-VR-SAVE-AREAS" CONDITION="ATR-VECTOR"> <title>VRSAVE and Vector Register Save Areas</title>
				<mediaobject><imageobject><imagedata scale=62 fileref="graphics/VR-SaveArea.png"
				format="PNG"></imageobject></mediaobject></figure>


				<variablelist id="CATEGORY-SPECIFIC-REGISTER-SAVE-AREAS">
					<title>Category-Specific Register Save Areas</title>

					<varlistentry id="NOT-VRS-SAVE-AREA" CONDITION="!ATR-VECTOR">
						<term>The section <emphasis>Category-Specific Register Save Areas</emphasis> has no defined elements.</term>
						<listitem><para></para></listitem>
					</varlistentry>

					<varlistentry id="VR-SAVE-AREA" CONDITION="ATR-VECTOR">
						<term><emphasis role="bold">Vector Register Save Area</emphasis></term>
						<listitem>
							<para>If a function changes the value in any nonvolatile vector
							register vr<emphasis>n</emphasis>, it shall first save the value of vr<emphasis>n</emphasis> in the
							<emphasis>Vector Register Save Area</emphasis>, in a quadword
							located 16 &times; (32 &minus; n) bytes before the low-addressed end
							of the <emphasis>VRSAVE save area</emphasis> (plus any required
							padding), as shown in <emphasis><xref linkend="FIG-VR-SAVE-AREAS"></emphasis>. The
							<emphasis>Vector Register Save Area</emphasis> shall have
							quadword alignment.</para>

						</listitem>
					</varlistentry>

					<varlistentry id="VECTOR-SCALAR-SAVE-AREA" CONDITION="ATR-VECTOR-SCALAR">
						<term>The section <emphasis>Category-Specific Register Save Areas</emphasis> has no defined elements.</term>
						<listitem>
							<para>Since all the additional register contents added by the
							VSX extension (namely the second doubleword on vs0-vs31) is volatile,
							there is no need to add a save area for VSX registers.  However, VSX
							registers vs14-vs31 overlap with the non-volatile floating-point
							registers f14-f31.  Therefore, it is necessary to save the corresponding
							floating point register in the floating-point register save area before
							using a VSX register in that interval.</para>
						</listitem>
					</varlistentry>
				</variablelist>
		
		
				<variablelist id="ADDITIONAL-CATEGORY-SPECIFIC-REGISTER-SAVE-AREA">
					<title>Additional Category Specific Register Save Areas</title>
					<varlistentry id="SPE-REGISTER-SAVE-AREA" CONDITION="ATR-SPE">
						<term><emphasis role="bold">SPE 64-bit General-Purpose Register Save Area</emphasis></term>
						<listitem>

						<para>If a function changes the value in the upper word of any
						nonvolatile general-purpose register r<emphasis>n</emphasis>, it shall first save the value
						of r<emphasis>n</emphasis> in the <emphasis>64-bit general-purpose register save
						area</emphasis>, in a doubleword located 8 &times; (32 &minus; <emphasis>n</emphasis>) bytes
						before the low-addressed end of the <emphasis>CR save area</emphasis>
						(plus any required padding) if the <emphasis>CR Save Area</emphasis> is
						present.  Otherwise, it is located in a doubleword 8 &times; (32 &minus; <emphasis>n</emphasis>)
						bytes before the low-address end of the <emphasis>General-Purpose
						Register Save Area</emphasis> (plus any required padding).  The
						<emphasis>64-bit General-Purpose Save Area</emphasis> shall have quadword
						alignment.  While not technically necessary, quadword alignment is required for congruence with AltiVec and VMX technology.</para>

						<figure ID="FIG-SPE-SAVE-AREA"> <title>SPE 64-bit General-Purpose Register Save Area</title> <mediaobject><imageobject><imagedata scale=62 fileref="graphics/SPE-SaveArea.png" format="PNG"></imageobject></mediaobject></figure>

						<note>
							<title>Note</title>

							<para>Note: The purpose of providing both 32-bit and 64-bit
							general register save areas is to reduce the stack usage for
							routines that use only the lower word of some nonvolatile
							registers, and both the lower and upper word of some other
							nonvolatile registers.  A compiler may choose to save and
							restore all 64 bits of each modified nonvolatile
							general-purpose register, as long as the debugging information
							reflects this choice.</para>
						</note>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term></term>
						<listitem>
						<note CONDITION="ATR-SPE && ATR-EABI" ><title>Note</title>
							<para>Note: If the compiler uses the 32-bit general save areas
							when possible, routines compiled in this manner that do not use
							any of the 64-bit instructions in the SPE architecture should
							remain Power Architecture EABI compliant (both in regards to
							stack layout, and in all other ways).</para>
						</note>
						</listitem>
					</varlistentry>

					<varlistentry id="NOT-SPE-REGISTER-SAVE-AREA" CONDITION="!ATR-SPE">
						<term><emphasis role="bold">Unused</emphasis></term>
						<listitem><para>The section <emphasis>Additional Category-Specific Register Save Areas</emphasis> has no defined elements.</para></listitem>
					</varlistentry>
				</variablelist>


				<figure ID="FIG-PARAM-LOCAL-SAVE-AREAS"> <title>Parameter Save Area and Local Variable Space</title> <mediaobject><imageobject><imagedata scale=65 fileref="graphics/Param-Local-SaveArea.png" format="PNG"></imageobject></mediaobject></figure>

				<variablelist id="PARAMETERS">
					<title>Parameter Save Area</title>
					<varlistentry id="PARAMETER-SAVE-AREA">
						<term><emphasis role="bold">Parameter Save Area</emphasis></term>
						<listitem><para>The <emphasis>Parameter Save Area</emphasis> shall be allocated by the caller, and shall be large enough to contain the parameters needed by the caller.  The calling function cannot expect that the contents of this save area are valid when returning from the callee.  Refer to <emphasis><xref linkend="FIG-PARAM-LOCAL-SAVE-AREAS"></emphasis> for information on the location of this space.</para></listitem>
					</varlistentry>
				</variablelist>

				<variablelist id="LOCAL-VARIABLES">
					<title>Local Variable Space</title>
					<varlistentry id="LOCAL-VARIABLE-SAVE-AREA">
						<term><emphasis role="bold">Local Variable Space</emphasis></term>
						<listitem><para>The <emphasis>Local Variable Space</emphasis> is used for allocation of local variables.  If the <emphasis>Parameter Save Area</emphasis> is in use, the <emphasis>Local Variable Space</emphasis> is located immediately above it, at a higher address, otherwise it is located immediately above the LR Save word.  There is no restriction on the size of this area.  Refer to <emphasis><xref linkend="FIG-PARAM-LOCAL-SAVE-AREAS"></emphasis> for information on the location of this space.</para></listitem>
					</varlistentry>
				</variablelist>



			</sect3>
		</sect2>

		<sect2 id="PARAM-PASS"><title>Parameter Passing</title>

			<para>For the Power Architecture, it is more efficient to pass arguments
			to functions in registers, rather than through memory. For the Power
			Architecture, the following parameters can be passed in
			registers.</para>

			<itemizedlist>
				<listitem>
					<para>Up to eight arguments can be passed in general-purpose
					registers r3 through r10</para>
				</listitem>

				<listitem CONDITION="ATR-SPE">
					<para>Up to eight 64-bit doubleword vector arguments are
					passed in general-purpose registers.</para>
				</listitem>

				<listitem CONDITION="ATR-CLASSIC-FLOAT">
					<para>Up to eight floating-point
					arguments can be passed in floating-point registers f1 through
					f8.</para>
				</listitem>

				<listitem CONDITION="ATR-CLASSIC-FLOAT && ATR-DFP">
					<para>Up to eight single-precision or double-precision decimal floating-point
					arguments can be passed in floating-point registers f1 through
					f8.</para>
				</listitem>

				<listitem CONDITION="ATR-CLASSIC-FLOAT && ATR-DFP">
					<para>Up to three quad-precision decimal floating-point
					arguments can be passed in even-odd floating-point register pairs f2 through
					f7.</para>
				</listitem>

				<listitem CONDITION="ATR-VECTOR">
					<para>Up to 12 vector parameters can be
					passed in v2 through v13.</para>
				</listitem>
			</itemizedlist>

			<para>If fewer arguments are needed, then the unused registers defined
			previously will contain undefined values on entry to the called
			function.</para>

			<para>If there are more arguments than registers, then a function must
			provide space for the arguments in its stack frame. When this happens,
			only the minimum storage needed to contain the extra arguments needs to
			be allocated in the stack frame.</para>

			<para>The following algorithm describes where arguments are passed for
			the C language. In this algorithm, arguments are assumed to be ordered
			from left (first argument) to right. The actual order of evaluation for
			arguments is unspecified.</para>

			<para><emphasis>gr</emphasis> contains the number of the next available general-purpose register.</para>

			<para CONDITION="ATR-CLASSIC-FLOAT"><emphasis>fr</emphasis> contains the number of the next
			available floating-point register.</para>

			<para CONDITION="ATR-VECTOR"><emphasis>vr</emphasis> contains the number of the next
			available vector register.</para>

			<sect3 id="PARAM-PASSING-REG-SELECTION-ALGORITHM"><title>Parameter Passing Register Selection Algorithm</title>

			<note>
				<title>Note</title>

				<para>Note: The following types refer to the type of the
				argument as declared by the function prototype.  The argument values
				will be converted (if necessary) to the types of the prototype
				arguments before passing them to the called function.</para>

				<para>If a prototype is not present, or it is a variable argument
				prototype and the argument is after the ellipsis, the type refers to the type of the data objects being passed to the
				called function.</para>
			</note>


			<itemizedlist>
				<listitem>
					<para><emphasis role="bolditalic">INITIALIZE</emphasis>: If the function return type requires a storage buffer,
					set <emphasis>gr</emphasis> = 4, else set <emphasis>gr</emphasis> = 3.</para>
					<para CONDITION="ATR-CLASSIC-FLOAT">Set <emphasis>fr</emphasis> = 1</para>
					<para CONDITION="ATR-VECTOR">Set <emphasis>vr</emphasis> = 2</para>
					<para>Set <emphasis>starg</emphasis> to the address of parameter word 1.</para>
				</listitem>

				<listitem>

					<para><emphasis role="bolditalic">SCAN</emphasis>: If there are no more arguments, terminate. Otherwise, select one
					of the following depending on the type of the next argument:</para>

					<itemizedlist>
						<listitem>
							<para><emphasis role="bold">SINGLE_GP</emphasis>:</para>
							<itemizedlist>
								<listitem>
									<para>A single integer no more than 32 bits</para>
								</listitem>

								<listitem CONDITION="ATR-SOFT-FLOAT">
									<para>A single-precision floating-point value if prototype is present</para>
								</listitem>

								<listitem CONDITION="ATR-SPE">
									<para>A 64-bit vector if the called function is not a
									variable-argument function</para>
								</listitem>

								<listitem>
									<para>A pointer to a data object</para>
								</listitem>

								<listitem>

									<para>A struct or union that shall be
									treated as a pointer to the data object, or to a copy of the
									data object when necessary to enforce call-by-value semantics.
									Only if the caller can ascertain that the data object is constant
									can it pass a pointer to the data object itself.</para> 

									<para
									CONDITION="ATR-PASS-COMPLEX-AS-STRUCT">This
									pointer treatment
									includes complex single-precision,
									double-precision, and quad-precision
									floating-point values.</para>

								</listitem>
								<listitem CONDITION="ATR-SOFT-FLOAT && ATR-DFP">
									<para>A single-precision decimal float</para>
								</listitem>
							</itemizedlist>

							<para>If <emphasis>gr</emphasis> > 10, go to
							<emphasis>OTHER</emphasis>. Otherwise, load the argument value
							into general-purpose register <emphasis>gr</emphasis>, set
							<emphasis>gr</emphasis> = <emphasis>gr</emphasis> &plus; 1, and
							go to <emphasis>SCAN</emphasis>. Values shorter than 32 bits are
							sign-extended or zero-extended, depending on whether they are
							signed or unsigned.</para>

						</listitem>
						<listitem>
							<para><emphasis role="bold">DUAL_GP</emphasis>:</para>
							<itemizedlist>
								<listitem>
									<para>A 64-bit integer</para>
								</listitem>

								<listitem CONDITION="ATR-SOFT-FLOAT">
									<para>A double-precision floating-point value</para>
								</listitem>

								<listitem CONDITION="ATR-SPE">
									<para>A 64-bit vector being passed to a variable-argument
									function</para>
								</listitem>

								<listitem CONDITION="ATR-PASS-COMPLEX-IN-GPRS">
									<para>A complex single-precision float</para>
								</listitem>

								<listitem CONDITION="ATR-SOFT-FLOAT && ATR-DFP">
									<para>A double-precision decimal float</para>
								</listitem>

							</itemizedlist>

							<para>If <emphasis>gr</emphasis> &gt; 9, go to <emphasis>OTHER</emphasis>. If <emphasis>gr</emphasis> is even, set <emphasis>gr</emphasis> = <emphasis>gr</emphasis> &plus; 1.
							Load the lower-addressed word of the argument into <emphasis>gr</emphasis> and the
							higher-addressed word into <emphasis>gr</emphasis> &plus; 1, set <emphasis>gr</emphasis> = <emphasis>gr</emphasis> &plus; 2, and go to
							<emphasis>SCAN</emphasis>.</para>
						</listitem>

						<listitem>
							<para><emphasis role="bold">QUAD_GP</emphasis>:</para>
							<itemizedlist>
								<listitem CONDITION="ATR-PASS-COMPLEX-IN-GPRS">
									<para>A complex double-precision float</para>
								</listitem>

								<listitem CONDITION="ATR-SOFT-FLOAT && ATR-LONG-DOUBLE-IBM">
									<para>A long double type of IBM AIX 128-bit Long Double
									format when no floating-point unit is
									present.</para>
								</listitem>

								<listitem CONDITION="ATR-SOFT-FLOAT && ATR-DFP">
									<para>A quad-precision decimal float</para>
								</listitem>
							</itemizedlist>
							<para>If <emphasis>gr</emphasis> &gt; 7, go to <emphasis>OTHER</emphasis>.  Load the words of the
							argument, in memory-address order, into <emphasis>gr</emphasis>, <emphasis>gr</emphasis> &plus; 1, <emphasis>gr</emphasis> &plus; 2 and
							gr &plus; 3, set <emphasis>gr</emphasis> = <emphasis>gr</emphasis> &plus; 4, and go to <emphasis>SCAN</emphasis>.</para>
						</listitem>

						<listitem CONDITION="ATR-LONG-DOUBLE-IBM">
							<para><emphasis role="bold">EIGHT_GP</emphasis>:</para>
							<itemizedlist>
								<listitem CONDITION="ATR-PASS-COMPLEX-IN-GPRS">
									<para>A complex long double type of IBM AIX 128-bit Long Double
									format.</para>
								</listitem>
							</itemizedlist>
							<para>If <emphasis>gr</emphasis> &gt; 3, go to <emphasis>OTHER</emphasis>.  Load the words of the argument, in
							memory-address order, into <emphasis>gr</emphasis> through <emphasis>gr</emphasis> &plus; 7, set <emphasis>gr</emphasis> = <emphasis>gr</emphasis> &plus; 8, and
							go to <emphasis>SCAN</emphasis>.</para>
						</listitem>

						<listitem CONDITION="ATR-CLASSIC-FLOAT">
							<para><emphasis role="bold">SINGLE_FP</emphasis>:</para>
							<itemizedlist>
								<listitem>
									<para>A single-precision floating-point value or a double-precision floating-point value</para>
								</listitem>
								<listitem CONDITION="ATR-DFP">
									<para>A single-precision decimal floating-point value or a double-precision decimal floating-point value</para>
								</listitem>
							</itemizedlist>
							<para>if <emphasis>fr</emphasis> &gt; 8, go to <emphasis>OTHER</emphasis>.  Otherwise load the argument into register <emphasis>fr</emphasis>, set <emphasis>fr</emphasis> to <emphasis>fr</emphasis> &plus; 1, and go
							to <emphasis>SCAN</emphasis></para>

						</listitem>
						<listitem CONDITION="ATR-LONG-DOUBLE-IBM || ATR-DFP">
							<para><emphasis role="bold">DOUBLE_FP</emphasis>:</para>
							<itemizedlist>
								<listitem CONDITION="ATR-LONG-DOUBLE-IBM">
									<para>An extended-precision floating-point value of IBM AIX 128-bit Long Double format</para>
								</listitem>
								<listitem CONDITION="ATR-DFP">
									<para>A quad-precision decimal floating-point value</para>
								</listitem>
							</itemizedlist>
							<para>If <emphasis>fr</emphasis> &gt; 7, go to <emphasis>OTHER</emphasis>.</para>
							<para CONDITION="ATR-DFP">
							If argument is quad-precision decimal floating-point value and <emphasis>fr</emphasis> &gt; 6, go
							to <emphasis>OTHER</emphasis>.</para>

							<para CONDITION="ATR-DFP"> If argument is
							quad-precision decimal floating-point value and is <emphasis>fr</emphasis> is odd, set
							(increment) <emphasis>fr</emphasis> to <emphasis>fr</emphasis> &plus; 1, load the argument into <emphasis>fr</emphasis> [even] and
							fr &plus; 1 [odd], set <emphasis>fr</emphasis> to <emphasis>fr</emphasis> &plus; 2, and go to <emphasis>SCAN</emphasis>.</para>

							<para>Otherwise load the argument into <emphasis>fr</emphasis> and <emphasis>fr</emphasis> &plus; 1, set <emphasis>fr</emphasis> to
							fr &plus; 2, and go to <emphasis>SCAN</emphasis>.</para>
						</listitem>

						<listitem CONDITION="ATR-VECTOR">
							<para><emphasis role="bold">SINGLE_VR</emphasis>:</para>
							<itemizedlist>
								<listitem>
									<para>A 128-bit vector type, unless being passed as one of
									the variable arguments to a variable-argument function.</para>
								</listitem>
							</itemizedlist>
							<para>if <emphasis>vr</emphasis> &gt; 13, go to <emphasis>OTHER</emphasis>. Otherwise, load the argument on register <emphasis>vr</emphasis>, set <emphasis>vr</emphasis> to <emphasis>vr</emphasis> &plus; 1, and
							go to <emphasis>SCAN</emphasis></para>
						</listitem>
						<listitem>
							<para><emphasis role="bolditalic">OTHER</emphasis>:</para>
							<itemizedlist>
								<listitem>

									<para>Arguments not otherwise handled are
									passed in the parameter save area of the caller's stack frame.
									Most of the types handled in SINGLE_GP, as defined previously,
									are considered to have 4-byte size and alignment, with
									simple integer types shorter than 32 bits sign- or
									zero-extended to 32 bits. Long long arguments are considered to
									have 8-byte size and alignment.  The same 8-byte arguments
									that must go in aligned pairs or registers are 8-byte
									aligned on the stack.</para>

									<para
									CONDITION="ATR-PASS-COMPLEX-IN-GPRS">Complex
									single-precision float arguments are considered
									to have 8-byte size and alignment.</para>

									<para CONDITION="ATR-LONG-DOUBLE-IBM && ATR-CLASSIC-FLOAT"> A long double type of
									IBM AIX 128-bit
									Long Double format is considered to have 8-byte alignment.  </para>

									<para CONDITION="ATR-DFP && ATR-CLASSIC-FLOAT">Decimal floating-point data types
									_Decimal128, _Decimal64, and _Decimal32 are considered to
									have 8-byte, 8-byte, and 4-byte alignment respectively.</para>

									<!-- ISA 2.06 Section 2.5.1 indicates that a
									     sequence of lfd instructions are to be used to
									     load a _Decimal128 from memory into a register.
									     The lfd instructions require 8-byte alignment.
									     The lfdp instructions, which would have
									     required 16-byte alignment have been 'phased
									     out' of ISA 2.05 and later and aren't to be
									     used for _Decimal128.  Therefore there is no
									     need for 16-byte alignment.  -->

									<para CONDITION="ATR-SPE">64-bit vector arguments are
									considered to have 8-byte size and alignment.</para>

									<para>Round <emphasis>starg</emphasis> up to a multiple of the alignment
									requirement of the argument and copy the argument
									byte-for-byte, beginning with its lowest addressed byte,
									into <emphasis>starg</emphasis>, ..., <emphasis>starg</emphasis> &plus; <emphasis>size</emphasis> &minus; 1. Set <emphasis>starg</emphasis> to <emphasis>starg</emphasis> &plus; <emphasis>size</emphasis>, and go to <emphasis>SCAN</emphasis>.</para>

									<para>Types handled in QUAD_GP, as defined previously, are only
									4-byte aligned when passed on the stack.</para>

									<para CONDITION="ATR-LONG-DOUBLE-IBM">Complex long double
									values of IBM AIX 128-bit Long Double
									format are only 4-byte aligned when passed on the
									stack.</para>

									<para CONDITION="ATR-CLASSIC-FLOAT && ATR-DFP ||
									ATR-LONG-DOUBLE-IBM">If <emphasis>fr</emphasis> &gt; 7 and the type is
									DOUBLE_FP, then set <emphasis>fr</emphasis> = 9 (to prevent subsequent
									SINGLE_FPs from being placed in registers after DOUBLE_FP
									arguments that would no longer fit in the registers).</para>

									<para>If <emphasis>gr</emphasis> &gt; 9 and the type is DUAL_GP, or <emphasis>gr</emphasis> &gt; 7
									and the type is QUAD_GP, <phrase
									CONDITION="ATR-LONG-DOUBLE-IBM"> or <emphasis>gr</emphasis> &gt; 3 and the type is
									EIGHT_GP, </phrase>then set <emphasis>gr</emphasis> = 11 (to
									prevent subsequent SINGLE_GPs from being placed in registers
									after DUAL_GP, QUAD_GP, or EIGHT_GP arguments that would no longer fit in the
									registers).</para>

								</listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>

			</sect3>
			<sect3 id="PARAM-PASSING-EXAMPLES"><title>Parameter Passing Examples</title>

			<para>The following section provides some examples using the algorithm described in <emphasis><xref linkend="PARAM-PASSING-REG-SELECTION-ALGORITHM">.</emphasis></para>

			<figure id="LD-AND-FP-PARAM-PASSING" CONDITION="ATR-CLASSIC-FLOAT && ATR-LONG-DOUBLE-IBM || ATR-LONG-DOUBLE-IS-DOUBLE">
				<title>Parameter Passing Example</title>
					<programlisting>
typedef struct {
  int    a;
  double dd;
} sparm;
sparm   s, t;
int     c, d, e;
long double ld;
double  ff, gg, hh;

x = func(c, ff, d, ld, s, gg, t, e, hh);</programlisting>
			</figure>

			<table id="PP-LONG-DOUBLE-CLASSIC" frame="none" CONDITION="ATR-CLASSIC-FLOAT && ATR-LONG-DOUBLE-IBM"><title>Parameter Passing Using IBM AIX 128-bit Long Double</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>c</entry>
							<entry>r3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>ff</entry>
							<entry>f1</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>d</entry>
							<entry>r4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ld</entry>
							<entry>f2, f3</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>r5</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>gg</entry>
							<entry>f4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>r6</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>e</entry>
							<entry>r7</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>hh</entry>
							<entry>f5</entry>
							<entry>(not stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

			<table id="PP-LONG-DOUBLE-SOFT" frame="none" CONDITION="ATR-SOFT-FLOAT && ATR-LONG-DOUBLE-IBM"><title>Parameter Passing Using IBM AIX 128-bit Long Double and Soft-Float</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>c</entry>
							<entry>r3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>ff</entry>
							<entry>r5,r6</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>d</entry>
							<entry>r7</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ld</entry>
							<entry>(none)</entry>
							<entry>08-23 (stored in parameter save area)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>(none)</entry>
							<entry>24-27 (stored)</entry>
						</row>

						<row>
							<entry>gg</entry>
							<entry>(none)</entry>
							<entry>32-39 (stored)</entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>(none)</entry>
							<entry>40-43 (stored)</entry>
						</row>

						<row>
							<entry>e</entry>
							<entry>(none)</entry>
							<entry>43-46 (stored)</entry>
						</row>

						<row>
							<entry>hh</entry>
							<entry>(none)</entry>
							<entry>47-54 (stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

			<table id="PP-LONG-DOUBLE-IS-DOUBLE" frame="none" CONDITION="ATR-CLASSIC-FLOAT && ATR-LONG-DOUBLE-IS-DOUBLE">
			<title>Parameter Passing Using long double is double</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>

						<row>
							<entry>c</entry>
							<entry>r3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>d</entry>
							<entry>r4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ld</entry>
							<entry>f1</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>r5</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ff</entry>
							<entry>f2</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>gg</entry>
							<entry>f3</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>r6</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>e</entry>
							<entry>r7</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>hh</entry>
							<entry>f4</entry>
							<entry>(not stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

			<table id="PP-LONG-DOUBLE-IS-DOUBLE-SOFT" frame="none" CONDITION="ATR-SOFT-FLOAT && ATR-LONG-DOUBLE-IS-DOUBLE">
			<title>Parameter Passing Using long double is double and Soft-Float</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>c</entry>
							<entry>r3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>ff</entry>
							<entry>r5,r6</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>d</entry>
							<entry>r7</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ld</entry>
							<entry>r9,r10</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>(none)</entry>
							<entry>08-11 (stored in parameter save area)</entry>
						</row>

						<row>
							<entry>gg</entry>
							<entry>(none)</entry>
							<entry>16-23 (stored) </entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>(none)</entry>
							<entry>24-27 (stored)</entry>
						</row>

						<row>
							<entry>e</entry>
							<entry>(none)</entry>
							<entry>28-31 (stored)</entry>
						</row>

						<row>
							<entry>hh</entry>
							<entry>(none)</entry>
							<entry>32-39 (stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>


			<figure CONDITION="ATR-VECTOR">
				<title>Vector Parameter Passing Example</title>
					<programlisting>
typedef struct {
  int     a;
  double dd;
} sparm;
sparm    s, t;
int      c;
vector int va, vb;
long double ld;
double ff, gg, hh;
x = func(c, ff, va, ld, s, gg, t, vb, hh);
</programlisting>
			</figure>

			<table id="PP-VECTOR" frame="none" CONDITION="ATR-VECTOR">
			<title>Parameter Passing of Vector Data Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>c</entry>
							<entry>r3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>ff</entry>
							<entry>f1</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>va</entry>
							<entry>v2</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ld</entry>
							<entry>f2, f3</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>r4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>gg</entry>
							<entry>f4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>r5</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>vb</entry>
							<entry>v3</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>hh</entry>
							<entry>f5</entry>
							<entry>(not stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>


			<figure CONDITION="ATR-SPE">
				<title>SPE Parameter Passing Example</title>
					<programlisting>
typedef struct {
  int     a;
  double dd;
} sparm;
sparm    s;
int      c;
__ev64_opaque__ va, vb;
float ff;
double gg;
x = func(c, ff, va, gg, vb, s);
</programlisting>
			</figure>

			<table id="PP-SPE" frame="none" CONDITION="ATR-SPE">
			<title>Parameter Passing of SPE Data Types</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>c</entry>
							<entry>r3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>ff</entry>
							<entry>r4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>va</entry>
							<entry>r5</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>gg</entry>
							<entry>r7, r8</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>vb</entry>
							<entry>r9</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>r10</entry>
							<entry>(not stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

			<figure CONDITION="ATR-DFP"><title>Decimal Floating-Point Parameter Passing Example</title>
<programlisting>typedef struct {
  _Decimal32  df;
	_Decimal64  dd;
	_Decimal128 dl;
} sparm;
sparm   s, t;
_Decimal32  d32;
_Decimal64  d64, e64;
_Decimal128 d128, e128;

x = func(d128, d64, d32, s, t, d128, e64, e128);</programlisting></figure>

			<table id="PP-DFP-CLASSIC" frame="none" CONDITION="ATR-CLASSIC-FLOAT && ATR-DFP">
			<title>Decimal Floating-Point Parameter Passing on Classic Power Architecture (with FPU)</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>d128</entry>
							<entry>f2-f3</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>d64</entry>
							<entry>f4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>d32</entry>
							<entry>f5</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>r3</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>r4</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>e64</entry>
							<entry>f6</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>e128</entry>
							<entry>(none)</entry>
							<entry>08-23 (stored in parameter save area)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

			<table id="PP-DFP-SOFT" frame="none" CONDITION="ATR-SOFT-FLOAT && ATR-DFP">
			<title>Decimal Floating-Point Parameter Passing with Soft-Float (without FPU)</title>
				<tgroup cols='3' colsep='0' rowsep='0'>
					<colspec colwidth='60' colname='c1' align="left">
					<colspec colwidth='60' colname='c2' align="left">
					<colspec colwidth='200' colname='c3' align="left">
					<thead>
						<row rowsep="1">
							<entry namest="c1">Parameter</entry>
							<entry namest="c2">Register</entry>
							<entry namest="c3">Byte Offset In Parameter Save Area</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>d128</entry>
							<entry>r3-r6</entry>
							<entry>(not stored in parameter save area)</entry>
						</row>

						<row>
							<entry>d64</entry>
							<entry>r7-r8</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>d32</entry>
							<entry>r9</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to s</entry>
							<entry>r10</entry>
							<entry>(not stored)</entry>
						</row>

						<row>
							<entry>ptr to t</entry>
							<entry>(none)</entry>
							<entry>08-11 (stored in parameter save area)</entry>
						</row>

						<row>
							<entry>e64</entry>
							<entry>(none)</entry>
							<entry>12-19 (stored)</entry>
						</row>

						<row>
							<entry>e128</entry>
							<entry>(none)</entry>
							<entry>20-35 (stored)</entry>
						</row>

					</tbody>
				</tgroup>
			</table>

		 	</sect3>
 		</sect2>

		<sect2 id="VARIABLE-ARG"><title>Variable Argument Lists</title>

			<para>C programs that are intended to be portable across different
			compilers and architectures must use the header file
			<emphasis>&lt;stdarg.h&gt;</emphasis> to deal with variable argument
			lists.  This header file contains a set of macro definitions that
			define how to step through an argument list.  The implementation of
			this header file may vary across different architectures, but the
			interface is the same.</para>

			<para>C programs that do not use this variable argument list header
			file, and assume that all the arguments are passed on the stack in
			increasing order on the stack are not portable, especially on
			architectures that pass some of the arguments in registers.  The Power
			Architecture is one of the architectures that passes some of the
			arguments in registers.</para>

			<para CONDITION="ATR-CLASSIC-FLOAT">CR bit 6 must be set by a variable
			argument list function caller that passes any arguments in floating-point registers.  The recommended instruction to achieve this is: <varname>creqv
			6,6,6</varname>.  It is recommended that CR bit 6 be cleared by variable argument
			list function callers that do not pass any arguments in floating-point
			registers, using the instruction <varname>crxor 6,6,6</varname>.</para>

			<para>The parameter list may be zero length and is only allocated when
			parameters are spilled.</para>

			<para CONDITION="ATR-SPE">For variable argument functions,
			64-bit vectors (both before and after the ellipsis) are
			passed in the low words of two consecutive registers, in the same manner
			as long long variables.</para>

		</sect2>

		<sect2 id="RETURN-VAL"><title>Return Values</title>

			<para CONDITION="ATR-CLASSIC-FLOAT">Functions that return float or
			double values shall place the result in register f1.  The float values
			will be rounded to single-precision.</para>

			<para CONDITION="ATR-CLASSIC-FLOAT && ATR-DFP">Functions that return
			single-precision or double-precision decimal floating-point values shall return the result
			in register f1.  Functions that return quad-precision decimal floating-point values shall return the result in the register pair f2 and f3.</para>

			<para CONDITION="ATR-CLASSIC-FLOAT && ATR-LONG-DOUBLE-IBM">Functions
			that return long double values shall place the result in registers f1 and
			f2.</para>

			<para CONDITION="ATR-SOFT-FLOAT">Functions shall return single-precision float
			values in r3, and double-precision values shall be returned with the low
			addressed word in r3 and the higher in r4.</para>

			<para CONDITION="ATR-SOFT-FLOAT && ATR-DFP">Functions shall return
			single-precision decimal floating-point values in r3, double-precision decimal
			float values in r3 and r4, and quad-precision decimal floating-point values in r3
			through r6.</para>

			<para CONDITION="ATR-SOFT-FLOAT && ATR-LONG-DOUBLE-IBM">Functions shall return long double values in r3 through r6.</para>

			<para CONDITION="ATR-SPE">Functions shall return values of 64-bit vector
			types in r3.</para>

			<para CONDITION="ATR-VECTOR">When the Vector facility is supported,
			functions shall return vector data type values in v2.</para>

			<para>Functions that return values of the following list of types shall
			place the result in register r3 as signed or unsigned integers as
			appropriate, sign extended or zero extended to 32 bits where
			necessary:</para>

			<itemizedlist>
				<listitem>
					<para>char</para>
				</listitem>
				<listitem>
					<para>enum</para>
				</listitem>
				<listitem>
					<para>short</para>
				</listitem>
				<listitem>
					<para>int</para>
				</listitem>
				<listitem>
					<para>long</para>
				</listitem>
				<listitem>
					<para>pointer to any type.</para>
				</listitem>
				<listitem>
					<para>_Bool</para>
				</listitem>
			</itemizedlist>

			<para CONDITION="ATR-LINUX">Aggregates or unions of any length will be
			returned in a storage buffer allocated by the caller.  The caller will
			pass the address of this buffer as a hidden first argument in r3,
			causing the first explicit argument to be passed in r4.  This hidden
			argument is treated as a normal formal parameter, and corresponds to the
			first doubleword of the parameter save area.</para>

			<para CONDITION="ATR-EABI">Aggregates or unions whose size is less than
			or equal to eight bytes shall be returned in r3 and r4, as if they were
			first stored in memory area and then the low-addressed word were loaded
			in r3 and the high-addressed word were loaded into r4. Bits beyond the
			last member of the structure or union are not defined.</para>

			<para CONDITION="ATR-EABI">Functions that return structures or unions which do not
			conform to the requirements of being returned in registers shall place
			the results in a storage buffer that has been pre-allocated by the
			caller. The address of this storage buffer shall be passed as the first
			argument in register r3 as a hidden argument resulting in <emphasis>gr</emphasis>
			being initialized to 4 as opposed to 3 in the argument passing
			algorithm in <emphasis><xref linkend="PARAM-PASSING-REG-SELECTION-ALGORITHM"></emphasis>.</para>

			<para>Functions that return values of type long long and unsigned long long shall place the
			result in registers r3 and r4.  The lower addressed word shall be placed in register r3, and the
			higher addressed word shall be in register r4.</para>

			<para CONDITION="ATR-PASS-COMPLEX-IN-GPRS">Functions that return values of type _Complex float
			shall place the results in registers r3 and r4.  The lower addressed word shall be placed in r3;
			the higher addressed word shall be in register r4.</para>

			<para CONDITION="ATR-PASS-COMPLEX-IN-GPRS">Functions that return values of type _Complex double
			shall place the results in registers r3 through r6, from lowest to highest addressed
			words.</para>

			<para CONDITION="ATR-PASS-COMPLEX-IN-GPRS && ATR-LONG-DOUBLE-IBM">Functions that return values of
			type _Complex long double shall place the result in registers r3 through
			r10, from lowest to highest addressed words.</para>

		</sect2>
	</sect1>

	<sect1 id="CODE-EX"><title>Coding Examples</title>

		<para>The following ISO C coding examples are provided as illustrations of
		how operations may be done, not how they shall be done, for calling
		functions, accessing static data, and transferring control from one
		part of a program to another.  They are shown as code fragments with
		simplifications to explain addressing modes, not necessarily show the
		optimal code sequences or compiler output.  The small data area is not
		used in any of them.</para>

		<para>The previous sections explicitly specify what a program, operating
		system, and processor may and may not assume and are the definitive
		reference to be used.</para>

		<para>In these examples, absolute code and position-independent code are
		referenced.</para>

		<para>When instructions hold absolute addresses, a program must be loaded
		at a specific virtual address in order to permit the absolute code model
		to work.</para>

		<para>When instructions hold relative addresses, a program can be loaded
		at various positions in virtual memory and is referred to as
		position-independent code model.</para>

		<sect2 id="MOD-OVER-EABI" CONDITION="ATR-EABI"><title>Code Model Overview</title>
			<para>When a process image is created, an executable has fixed addresses.</para>
		</sect2>
		<sect2 id="MOD-OVER" CONDITION="!ATR-EABI"><title>Code Model Overview</title>
			<para>A shared object file is mapped with virtual addresses to
			avoid conflicts with other segments in the process.  Because of this
			mapping, shared objects use position-independent code, which
			means that the instructions do not contain any absolute addresses.  Avoiding the use of absolute addresses
			allows shared objects to be loaded into different virtual address spaces
			without code modification, which can allow multiple processes to share
			the same text segment for a shared object file.</para>

			<para>There are two techniques used to deal with position-independent code.</para>

			<itemizedlist>
				<listitem>
					<para>First, branch instructions use an offset to the current EA (Effective Address) or use
					registers to hold addresses. The Power Architecture provides both EA-relative branch
					instructions and branch instructions that use registers. In both cases, absolute addressing is
					not required.</para>
				</listitem>
				<listitem>

						<para>Second, when absolute addressing is required, the value can be
						computed with a <emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global
						Offset Table</link></emphasis> (GOT), which holds the information for
						address computation. Position-independent executables or shared objects
						have a GOT in the data segment that holds addresses.
						When the system creates a memory image from the file, the GOT entries
						are updated to reflect the absolute virtual addresses that were assigned
						for the process. These data segments are private, while the text
						segments are shared. The Power Architecture will generate a more
						efficient GOT if it is less than 65,536 bytes. A larger GOT will require
						more general code in order to access all of its entries.</para>

				</listitem>
			</itemizedlist>

			<para>The GOT size gives programs two choices &mdash; more efficient code
			with a size restriction, or less efficient code without size
			restrictions. In the following sections, the term <emphasis>small model</emphasis>
			position-independent code refers to the use of efficient code with a
			smaller GOT (no more than 65,536 bytes), and the term <emphasis>large model</emphasis>
			position-independent code refers to the use of less efficient code
			without any restriction on the size of the GOT.</para>

		</sect2>

		<sect2 id="PRO-EP"><title>Function Prologue and Epilogue</title>

			<para>A function's prologue and epilogue is detailed in this section.</para>

			<sect3 id="PROLOGUE"><title>The Purpose of a Function's Prologue</title>
				<itemizedlist><listitem><para>Create a stack frame when required.</para>
					</listitem>
					<listitem>
						<para>Save any nonvolatile registers that are used by the function.</para>
					</listitem>
					<listitem>
						<para>Save any limited-access bits that are used by the function,
						per the rules described earlier.</para>
					</listitem>
				</itemizedlist>
			</sect3>

			<sect3 id="EPILOGUE"><title>The Purpose of a Function's Epilogue</title>
				<itemizedlist>
					<listitem><para>Restore all registers
					and limited-access bits that were saved
					by the function's prologue.</para>
					</listitem>

					<listitem><para>Restore the last stack frame.</para></listitem>

					<listitem><para>Return to the caller.</para></listitem>
				</itemizedlist>
			</sect3>
			<sect3 id="PRO-EP-RULES"><title>Rules for Prologue and Epilogue Sequences</title>
			
			<para>Set function prologue and function epilogue code sequences are not
			imposed by this ABI.  There are several rules that must be adhered to in order to ensure reliable
			and consistent call chain backtracing.</para>

			<itemizedlist>
				<listitem>
					<para>Before a function calls any other function, it shall establish
					its own stack frame, whose size shall be a multiple of 16 bytes, and
					shall save the link register at the time of entry in the LR save
					area of its caller's stack frame.</para>
				</listitem>

				<listitem>
					<para>The calling sequence does not restrict how languages leverage
					the <emphasis>local variable space</emphasis> of the stack frame, and there is no
					restriction on the size of this section.</para>
				</listitem>

				<listitem>
					<para>The <emphasis>parameter save area</emphasis> shall be allocated by the caller,
					and shall be large enough to contain the parameters needed by the
					caller. Its contents are not saved across function calls.</para>
				</listitem>

				<listitem>

					<para>In instances where a function's prologue creates a stack frame,
					the backchain word of the stack frame shall be updated atomically with the
					value of the stack pointer (r1).  This task can be done by using one of the following <emphasis>Store
					Word with Update</emphasis> instructions:</para>

					<itemizedlist>
						<listitem>
							<para><emphasis>Store Word with Update</emphasis> instruction with relevant
							negative displacement for stack frames that are smaller than 32
							KB.</para>
						</listitem>

						<listitem>
							<para><emphasis>Store Word with Update Indexed</emphasis> instruction where
							the two's complement size of the stack frame has been computed,
							using <varname>addis</varname> and <varname>addi</varname> or <varname>ori</varname> instructions, and then loaded into a
							volatile register for stack frames that are 32 KB or
							greater.</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>The deallocation of a function's stack frame must be an atomic
					operation.  This task can be accomplished by one of the following methods given
					below:</para>

					<itemizedlist>
						<listitem>
							<para>Increment the stack pointer by the identical value that it was
							originally decremented in the prologue when the stack frame was
							created.</para>
						</listitem>

						<listitem>
							<para>Load the stack pointer (r1) with the value in the backchain word
							in the stack frame.</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>

					<para>If any nonvolatile registers are to be used by the function the contents
					of the register must be saved into a <emphasis>register save area</emphasis>.
					See <emphasis><xref linkend="SAVE-AREAS"></emphasis> for information on all of
					the optional register save areas.</para>

					<para>Saving and/or restoring nonvolatile registers used by the function can be
					accomplished using in-line code. Alternatively one of the system subroutines
					described in <emphasis><xref linkend="SAVE-RES"></emphasis> may offer a more efficient alternative to
					in-line code, especially in cases where there are many registers to be saved or
					restored.</para>

				</listitem>

			</itemizedlist>


			<para>Unlike some other processors that implement the Power Architecture embedded processors may
			support <emphasis>load and store multiple</emphasis> Power Architecture instructions in
			little-endian mode. On big-endian implementations they may or may not be slower than the
			register-at-a-time saves, but reduce the instruction footprint.</para>

			<para>Position independent functions which make external data references will need to load a
			nonvolatile register with a pointer to a <emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> as show in <xref
			linkend="SMALL-MODEL-POS-IND-LOAD-STORE">.  In cases where external data references are only
			made from within conditional code the loading of a <emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> pointer can be delayed
			until it is needed.</para>
			</sect3>
		</sect2>

		<sect2 id="SAVE-RES"><title>Register Saving and Restoring Functions</title>

			<para>This section describes functions that can be used to save and
			restore contents of nonvolatile registers. The use of these routines,
			rather than performing these saves and restores inline in the prologue
			and epilogue of functions, can help reduce code footprint.</para>

			<para>This section details register saving and restoring functions.  The calling conventions of
			these functions are not standard and the executables or shared objects that use these
			functions must statically link them.  The specific calling convention for each of these
			functions is described in <emphasis><xref
			linkend="SAVE-AND-RESTORE-ROUTINES"></emphasis>.</para>


			<para CONDITION="ATR-SPE && ATR-SOFT-FLOAT">The use of a merged register
			file removes the need for distinct routines for saving and restoring
			floating-point registers. However, in order to conserve stack space,
			this ABI describes several new routines to allow the compiler to use the
			minimum stack space for holding copies of nonvolatile registers.  See
			<emphasis><xref linkend="SPE-FUNCTIONS"></emphasis> for information on the
			routines.</para>

			<para CONDITION="ATR-SPE">For situations where stack space is not at a
			premium, the compiler can elect to only use the 64-bit save and restore
			functions for functions that require some use of the upper halves of the
			registers, and traditional 32-bit save and restore functions for code that
			uses only classic instructions.</para>

			<para>There are several cases to consider with respect to
			saving/restoring nonvolatile registers for a function:</para>

			<itemizedlist>
				<listitem>
					<para>No nonvolatile registers need saving or restoring.</para>
				</listitem>
				<listitem>
					<para>Only 32-bit nonvolatile registers need to be saved or restored. In this case, the classic (32-bit) save and restore
					functions, or the <varname>stmw</varname> and <varname>lmw</varname> instructions, can be used.</para>
				</listitem>
			</itemizedlist>

			<itemizedlist CONDITION="ATR-SPE">
				<listitem>
					<para>Only 64-bit nonvolatile registers need to be saved or restored. In this case, 64-bit versions of the classic
					save and restore functions can be used. There is no equivalent to <varname>stmw</varname>/<varname>lmw</varname> for both halves of a 64-bit
					register.</para>
				</listitem>
				<listitem> <para>A mixture of 32-bit and 64-bit
				nonvolatile registers need saving or restoring. To minimize complexity, the 32-bit
				nonvolatile registers shall be contiguous and at the upper end of the
				registers (r<emphasis>N</emphasis> &minus; r31). This also allows the <varname>stmw</varname> and <varname>lmw</varname> instructions to
				still be used, if desired. The 64-bit nonvolatile registers shall
				also be contiguous (r<emphasis>M</emphasis> &minus; r(<emphasis>N</emphasis> &minus; 1)). The registers are saved or restored by
				calling both a 32-bit save and restore function and a 64-bit save and restore
				function.</para>
				</listitem>
			</itemizedlist>

			<para>Saving and restoring functions also have variants (<emphasis>_g</emphasis> for register save routines,
			<emphasis>_x</emphasis> and <emphasis>_t</emphasis> for register restore routines) that bundle some common prologue and epilogue
			operations to reduce overhead and code footprint by a few instructions.
			These are described in more detail in the following paragraphs.</para>

			<para>The 32-bit save and restore functions restore consecutive 32-bit
			registers from register <emphasis>m</emphasis> through register 31.</para>

			<para CONDITION="ATR-SPE">The simple 64-bit save and restore functions
			restore consecutive 64-bit registers from register <emphasis>m</emphasis> through register
			31. The more complex (CTR-based) 64-bit save and restore functions save
			and restore consecutive 64-bit registers from register <emphasis>m</emphasis> through
			register n, and use the value <emphasis>N</emphasis> &minus; <emphasis>m</emphasis> &plus; 1 in the CTR register to determine how many
			registers to save.</para>

			<para>Higher-numbered registers are saved at higher addresses within a save area.</para>

			<para>All of the 32-bit save and restore functions in this section expect
			the address of the backchain word to be contained in r11.  The back
			chain word is the next word after the end of the 32-bit general register
			save area.  r11 is not modified by these functions.</para>

			<para CONDITION="ATR-SPE">The value held in r11 for the 64-bit
			save and restore functions varies on the type of function.

			<itemizedlist>
				<listitem>
					<para>All the non-CTR 64-bit save and restore functions described in
					this section expect r11 to contain the address of the backchain
					word, adjusted by subtracting 144. The adjustment by 144 allows the
					immediate form of the 64-bit load/store instructions to be used
					(they have an unsigned immediate).</para>
				</listitem>
				<listitem>
					<para>The CTR-based 64-bit save and restore functions described in this
					section expect the CTR to contain the number of registers to save
					(1:18). Register r11 should be calculated by taking the 8-byte
					aligned address pointing to the doubleword beyond the 64-bit
					general register save area, adjusting it by subtracting 8 times the
					last (highest) 64-bit nonvolatile register number to be
					saved or restored and adding 8 &times; 13 &equals; 104. These two adjustments allow
					positive offsets, and adjust so that the last register saved is placed
					directly below the 32-bit general register save area. These two adjustments allow a single routine, with fixed offsets, to be
					used across all potential cases. The doubleword beyond
					the 64-bit general-purpose register save area could be the low word of the 32-bit
					general-purpose register save area, the CR save word, or a pad word, depending on the
					number of 32-bit registers saved and the presence or absence of a CR
					save word.</para>
				</listitem>
			</itemizedlist></para>

			<para CONDITION="ATR-SPE">These rules are summarized in the following table.

			<table frame="none">
				<title>SPE Save And Restore Rules</title>
				<tgroup cols='2' colsep='0' rowsep='0'>
				<colspec colwidth='220' colname='c1' align="left">
				<colspec colwidth='180' colname='c2' align="left">
				<thead>
					<row rowsep='1'><entry>Function Type</entry><entry>r11 Contents</entry></row>
				</thead>
				<tbody>
					<row>
						<entry>save &amp; restore 32-bit values (r<emphasis>M</emphasis> &dash; r31)</entry>
						<entry>address of backchain</entry>
					</row>	

					<row>
						<entry>save &amp; restore 64-bit values (r<emphasis>M</emphasis> &dash; r31)</entry>
						<entry>address of backchain (or pad word below CR save word if CR is saved) &minus; 144</entry>
					</row>	

					<row>
						<entry>save &amp; restore 64-bit values (r<emphasis>M</emphasis> &dash; r<emphasis>N</emphasis>, where <emphasis>N</emphasis> != 32)</entry>
						<entry>address of low end of 32-bit save area/CR save word/padding, adjusted by subtracting (8 &times; <emphasis>N</emphasis>) and adding 104.</entry>
					</row>	
				</tbody>
				</tgroup>
			</table></para>

			<sect3 id="SPE-FUNCTIONS">
				<title>Details about the Functions</title>

				<para>Each function described in this section is a family of 18
				functions with identical behavior except for the number and kind of
				registers affected.</para>

				<para CONDITION="ATR-SPE">The function names use the notation [32/64]
				to designate the use of a 32 for the 32-bit general-purpose register functions
				and a 64 for the 64-bit general-purpose register functions. The suffix
				<emphasis>_m</emphasis>;
				designates the portion of the name that would be replaced by the first
				register to be saved. That is, to save registers 18 through 31, call <varname>_save32gpr_18()</varname>.</para>

				<para>There are two families of register saving functions:</para>

				<itemizedlist>
					<listitem>
						<para>The following simple register saving functions save the indicated registers and return</para>
						<programlisting>
<varname>_savegpr_m()</varname>
</programlisting>
						<programlisting CONDITION="ATR-CLASSIC-FLOAT">
<varname>_savefpr_m()</varname>
</programlisting>
						<programlisting CONDITION="ATR-SPE">
<varname>_save32gpr_m()</varname>
<varname>_save64gpr_m()</varname> and <varname>_save64gpr_ctr_m()</varname>
</programlisting>
					</listitem>
					<listitem>
						<para>The following GOT register saving functions do not return directly:</para>
						<programlisting>
<varname>_savegpr_m_g()</varname>
</programlisting>
						<programlisting CONDITION="ATR-CLASSIC-FLOAT">
<varname>_savefpr_m_g()</varname>
</programlisting>
						<programlisting CONDITION="ATR-SPE">
<varname>_save32gpr_m_g()</varname>
<varname>_save64gpr_m_g()</varname> and <varname>_save64gpr_ctr_m_g()</varname>
</programlisting>

						<para>Instead these functions branch to
						<varname>_GLOBAL_OFFSET_TABLE_&minus;4</varname>, relying on a
						<varname>blrl</varname> instruction at that address to return to the
						caller of the save function with the address of a <emphasis><link
						linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> in
						the link register.</para>

					</listitem>
				</itemizedlist>

				<para>There are three families of register restoring functions.</para>

				<itemizedlist>
					<listitem>
						<para>The following simple register restoring functions restore the indicated registers and
						return:</para>
						<programlisting>
<varname>_restgpr_m()</varname>
</programlisting>
						<programlisting CONDITION="ATR-CLASSIC-FLOAT">
<varname>_restfpr_m()</varname>
</programlisting>
						<programlisting CONDITION="ATR-SPE">
<varname>_rest32gpr_m()</varname> and <varname>_rest32gpr_m_t()</varname>
<varname>_rest64gpr_m()</varname> and <varname>_rest64gpr_ctr_m()</varname>
</programlisting>
					</listitem>
					<listitem>
						<para>The following exit functions restore the indicated registers and, relying on the registers being
						restored to be adjacent to the backchain word, restore the link register from the LR save word,
						remove the stack frame, and return through the link register:</para>
						<programlisting>
<varname>_restgpr_m_x()</varname>
</programlisting>
						<programlisting CONDITION="ATR-CLASSIC-FLOAT">
<varname>_restfpr_m_x()</varname>
</programlisting>
						<programlisting CONDITION="ATR-SPE">
<varname>_rest32gpr_m_x()</varname>
<varname>_rest64gpr_m_x()</varname>
</programlisting>
					</listitem>
					<listitem>
						<para>The following tail functions restore the registers, place the LR save word into r0, remove the
						stack frame, and return to their caller:</para>
						<programlisting>
<varname>_restgpr_m_t()</varname>
</programlisting>
						<programlisting CONDITION="ATR-CLASSIC-FLOAT">
<varname>_restfpr_m_t()</varname>
</programlisting>
						<programlisting CONDITION="ATR-SPE">
<varname>_rest64gpr_m_t()</varname>
</programlisting>
						<para>The caller can thus implement a tail call by moving r0 into the link register and branching to
						the tail function. The tail function then detects the call from the function above the one that
						made the tail call and, when done, returns directly to it.</para>
					</listitem>
				</itemizedlist>

				<note CONDITION="ATR-SPE">
					<title>Note</title> <para>Note: There are no functions <varname>_rest64gpr_ctr_m_x()</varname> or <varname>_reset64gpr_ctr_m_t()</varname>, because the backchain word is not directly above the location of the 64-bit save area in these cases. In this case, the
					64-bit registers shall be restored first, followed by a call to <varname>_rest32gpr_m_x()</varname> or <varname>_rest32gpr_m_t()</varname>.</para>

					<para>Note: If a CR save word is used, even if only 64-bit registers are saved,
					<varname>_rest64gpr_m_x()</varname> and <varname>rest64gpr_m_t()</varname> cannot be used, because the backchain word is not directly above the end of the
					64-bit save area.</para>
				</note>

				<para CONDITION="ATR-SPE">The following assembly code shows an example of an implementation.

				<programlisting id="SAVE32GPR-EX">
_save32gpr_14:       stw r14,&minus;72(r11)
_save32gpr_15:       stw r15,&minus;68(r11)
                ...
_save32gpr_30:       stw r30,&minus;8(r11)
_save32gpr_31:       stw r31,&minus;4(r11)
                     blr


_save64gpr_14:       evstdd r14,0(r11)
_save64gpr_15:       evstdd r15,8(r11)
                ...
_save64gpr_30:       evstdd r30,128(r11)
_save64gpr_31:       evstdd r31,136(r11)
                     blr


_save64gpr_ctr_14:   evstdd r14,0(r11)
                     bdz _save64gpr_ctr_done
_save64gpr_ctr_15:   evstdd r15,8(r11)
                     bdz _save64gpr_ctr_done
                ...
_save64gpr_ctr_30:   evstdd r30,128(r11)
                     bdz _save64gpr_ctr_done
_save64gpr_ctr_31:   evstdd r31,144(r11)
_save64gpr_ctr_done: blr


_rest32gpr_14:       lwz r14,&minus;72(r11)
_rest32gpr_15:       lwz r15,&minus;68(r11)
                ...
_rest32gpr_30:       lwz r30,&minus;8(r11)
_rest32gpr_31:       lwz r31,&minus;4(r11)
                     blr


_rest64gpr_14:       evldd r14,0(r11)
_rest64gpr_15:       evldd r15,8(r11)
                ...
_rest64gpr_30:       evldd r30,128(r11)
_rest64gpr_31:       evldd r31,136(r11)
                     blr


_rest64gpr_ctr_14:   evldd r14,0(r11)
                     bdz _rest64gpr_ctr_done
_rest64gpr_ctr_15:   evldd r15,8(r11)
                     bdz _rest64gpr_ctr_done
                ...
_rest64gpr_ctr_30:   evldd r30,128(r11)
                     bdz _rest64gpr_ctr_done
_rest64gpr_ctr_31:   evldd r31,136(r11)
_rest64gpr_ctr_done: blr
</programlisting></para>

				<para>The GOT forms of the save routines (with a suffix of <emphasis>_g</emphasis>) all replace the <varname>blr</varname> with <varname>b
				_GLOBAL_OFFSET_TABLE_ &minus; 4</varname>.</para>

				<para>The exit forms of the restore routines (with a suffix of <emphasis>_x</emphasis>) perform the following tasks in place of the <varname>blr</varname>:</para>

				<programlisting CONDITION="ATR-CLASSIC-FLOAT">
_rest[fg]pr_m_x      replaces the blr with    lwz r0,4(r11)
                                              mr r1,r11
                                              mtlr r0
                                              blr
</programlisting>
				<programlisting CONDITION="ATR-SPE">
_rest32gpr_m_x       replaces the blr with    lwz r0,4(r11)
                                              mr r1,r11
                                              mtlr r0
                                              blr
_rest64gpr_m_x       replaces the blr with    lwz r0,148(r11)
                                              addi r1,r11,144
                                              mtlr r0
                                              blr
</programlisting>

				<para>The tail functions (with a suffix of <emphasis>_t</emphasis>) are similar to the exit functions, except
				they skip the <varname>mtlr</varname> instruction.</para>

				<note CONDITION="ATR-SPE"><title>note</title><para>Note: The CTR-based 64-bit restore
				functions cannot perform the exit and tail optimizations as
				implemented here, because the address of the backchain word and the return
				address are not at a fixed offset from r11.</para>

				<para>Note: For slightly higher performance in
				the restore function variants, the <varname>lwz</varname> of r0 and the restore of r31 could be
				reordered (but the label for <varname>_rest[32/64]gpr_31*()</varname> shall now point to the
				<varname>lwz</varname> of r0, not the load of r31).</para></note>

				<para CONDITION="ATR-SPE">The following assembly source code provides and an example restore function variant using
				<varname>_rest32gpr_m_x()</varname>.

				<programlisting>
 ...
_rest32gpr_30_x:     lwz    r30,&minus;8(r11)
_rest32gpr_31_x:     lwz    r0,4(r11)
                     lwz    r31,&minus;4(r11)
                     mtlr   r0
                     mr     r1,r11   # Change to addi r1,r11,144
                                     # for _rest64gpr* blr
</programlisting></para>

				<para CONDITION="ATR-SPE">The following figure shows sample prologue
				and epilogue code with full saves of all the nonvolatile general-purpose
				registers (r14 through r25 as 64-bit, r26 through r31 as 32-bit) and a
				stack frame size of less than 32 KB. The variable <emphasis>len</emphasis> refers to
				the size of the stack frame. The example assumes that the function
				does not alter the nonvolatile fields of the CR register and does no dynamic
				stack allocation.

				<note> <title>Note</title> <para>Note: The following code assumes that the size of
				the executable or shared object in which the code appears is small enough
				that a relative branch can reach from any part of the text section to any part of the
				<emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> or
				the <emphasis><link linkend="PLT">Procedure Linkage Table</link></emphasis>.  Because relative branches can reach &plusmn; 32 MB, this
				restriction is not considered serious.  See <emphasis><xref
				linkend="PROG-LOAD-DL"></emphasis> for more information. </para> </note>

				<programlisting>
function:
       mflr    r0                      # Save return addr in caller's frame
       stw     r0,4(r1)                # . . .
       li      r0,12                   # Set up CTR with number of 64-bit
                                       # registers to save.
       mr      r11,r1                  # Set up r11 with backchain pointer
       mtctr   r0
       stwu    r1,&minus;len(r1)             # Establish new frame
       bl      _save32gpr_26           # Save 32-bits of some GPRs
       addi    r11,r11,&minus;120            # Adjust r11 down 24 bytes to bottom
                                       # of 32-bit area, and down another 96
                                       # bytes for the offset
       mflr    r31                     # Place GOT ptr in r31
       bl      _save64gpr_ctr_14_g     # Save 64-bit nonvolatile GPRs and
                                       # fetch the GOT ptr
                                       # Save CR here if necessary
                                       # Body of function
       li      r0,12                   # Set up CTR with number of regs to
                                       #  restore
       mtctr   r0
       addi    r11,r1,len&minus;120          # Compute offset from low end of
                                       # 32-bit save area
       bl      _rest64gpr_ctr_14       # Restore 64-bit GPRs
                                       # Restore CR here if necessary
       addi    r11,r1,len              # Compute backchain word address
       b       _rest32gpr_26_x         # Restore 32-bit GPRs and return
</programlisting></para>
			</sect3>

			<sect3 id="VECTOR-REG-SAVE-RESTORE-FUNCTIONS" CONDITION="ATR-VECTOR">
				<title>Register Saving and Restoring Functions (Vector)</title>

				<para>The vector register saving and restoring functions described in
				this section are not part of the ABI. They are defined here only to
				encourage uniformity among compilers in the code used to save and
				restore VRs.</para>

				<para>On entry to the functions described in this section, r0 contains
				the address of the word just beyond the end of the vector register
				save area, and they leave r0 undisturbed. They modify the value of
				r12. The following code is an example of saving a vector
				register.

				<programlisting>
_savevr_20: addi          r12,r0,&minus;192
            stvx          v20,r12,r0               # save v20
_savevr_21: addi          r12,r0,&minus;176
            stvx          v21,r12,r0               # save v21
_savevr_22: addi          r12,r0,&minus;160
            stvx          v22,r12,r0               # save v22
_savevr_23: addi          r12,r0,&minus;144
            stvx          v23,r12,r0               # save v23
_savevr_24: addi          r12,r0,&minus;128
            stvx          v24,r12,r0               # save v24
_savevr_25: addi          r12,r0,&minus;112
            stvx          v25,r12,r0               # save v25
_savevr_26: addi          r12,r0,&minus;96
            stvx          v26,r12,r0               # save v26
_savevr_27: addi          r12,r0,&minus;80
            stvx          v27,r12,r0               # save v27
_savevr_28: addi          r12,r0,&minus;64
            stvx          v28,r12,r0               # save v28
_savevr_29: addi          r12,r0,&minus;48
            stvx          v29,r12,r0               # save v29
_savevr_30: addi          r12,r0,&minus;32
            stvx          v30,r12,r0               # save v30
_savevr_31: addi          r12,r0,&minus;16
            stvx          v31,r12,r0               # save v31
            blr                                    # return to epilogue
</programlisting></para>

				<para>The following code shows how to restore a vector register.

				<programlisting>
_restvr_20: addi          r12,r0,&minus;192
            lvx           v20,r12,r0               # restore v20
_restvr_21: addi          r12,r0,&minus;176
            lvx           v21,r12,r0               # restore v21
_restvr_22: addi          r12,r0,&minus;160
            lvx           v22,r12,r0               # restore v22
_restvr_23: addi          r12,r0,&minus;144
            lvx           v23,r12,r0               # restore v23
_restvr_24: addi          r12,r0,&minus;128
            lvx           v24,r12,r0               # restore v24
_restvr_25: addi          r12,r0,&minus;112
            lvx           v25,r12,r0               # restore v25
_restvr_26: addi          r12,r0,&minus;96
            lvx           v26,r12,r0               # restore v26
_restvr_27: addi          r12,r0,&minus;80
            lvx           v27,r12,r0               # restore v27
_restvr_28: addi          r12,r0,&minus;64
            lvx           v28,r12,r0               # restore v28
_restvr_29: addi          r12,r0,&minus;48
            lvx           v29,r12,r0               # restore v29
_restvr_30: addi          r12,r0,&minus;32
            lvx           v30,r12,r0               # restore v30
_restvr_31: addi          r12,r0,&minus;16
            lvx           v31,r12,r0               # restore v31
            blr                                    # return to epilogue
</programlisting></para>
			</sect3>
		</sect2>

		<sect2 id="PROFILING">
			<title>Profiling</title>

			<para>This section describes how profiling (counting the number of times
			that a function is called) can be performed on the Power Architecture. Profiling
			is not required for ABI compliance. If profiling is supported, this implementation is one of those possible.</para>

			<para>The code in <xref linkend="PROFILING-FIGURE"> can be inserted at the beginning of any
			function, before the execution of the prologue code. The following is
			a high-level explanation of this code.</para>

			<itemizedlist>
				<listitem>
					<para>The link register is saved in the LR save word of the caller stack frame.</para>
				</listitem>
				<listitem>
					<para>The register r0 contains the address of the count variable, which is initialized
					to 0.</para>
				</listitem>
				<listitem>
					<para>The function, <varname>_mcount()</varname>, gets called. This function increments the count
					variable. It also needs to restore the link register to its original value so that it
					can handle the case where the profiled function does not save the link register
					itself.</para>
				</listitem>
			</itemizedlist>
			<figure ID="PROFILING-FIGURE"><title>Profiling Example</title>
			<programlisting>
.function_mc:
               .data
               .align   2
               .long    0
               .text
function:
               mflr     r0
               addis    r11,r0,.function_mc@ha
               stw      r0,4(r1)
               addi     r0,r11,.function_mc@1
               bl       _mcount
			</programlisting></figure>

			<note>
			<title>Note</title> 
				<para>NOTE: In the figure, the assembler expression symbol@l
				represents the lower-order 16 bits of the value for symbol. The
				assembly expression symbol@ha represents the higher-order 16 bits of
				the value for symbol, adjusted so that the addition of symbol@l and
				the shifted value of symbol@ha added together create the correct value
				of symbol. The adjustment is needed because symbol@l is a signed
				value.</para>
			</note>
		</sect2>

		<sect2 id="DATA-OBJ">
			<title>Data Objects</title>

			<para>Data objects with static storage duration are detailed here; stack
			resident data objects are omitted because the virtual address of
			stack resident data objects are derived relative to the stack or frame
			pointers.</para>

			<para>The only instructions that can access memory in the Power
			Architecture are load and store instructions.  Programs typically access
			memory by placing the address of the memory location into a register and
			accessing the memory location indirectly through the registers because
			Power Architecture instructions cannot hold 32-bit addresses
			directly.  The values of symbols or their absolute virtual address are
			placed directly into instructions for symbolic references in absolute
			code.</para>

			<para>Absolute addresses are not permitted in position-independent
			instructions. The signed offset into the <emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> of the
			symbol is held in position-independent instructions that reference
			symbols.  Then the absolute address of the table entry for the
			particular symbol can be derived by adding the offset to the appropriate
			<emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> address using a general-purpose register.  <xref linkend="ABS-LOAD-STORE"> shows
			an example of this method, r31 loaded in the sample prologue. </para>

			<para>Examples of absolute and position-independent compilations are
			shown in the following figures.  These examples show the C language
			statements together with the generated assembly language.  The
			assumption for the following figures is that only executables can use absolute addressing while shared
			objects can use position-independent code addressing. The figures are intended to
			demonstrate the compilation of each C statement independent of its
			context, hence there can be redundant operations in the code.</para>

			<figure id="ABS-LOAD-STORE">
			<title>Absolute Load and Store Example</title>
			<programlisting>
C code                             Assembly code
extern int src;                    .extern src
extern int dst;                    .extern dst
extern int *ptr;                   .extern ptr
                                   .section     ".text"
dst = src;                         lis 9,src@ha
                                   lwz 0,src@l(9)
                                   lis 9,dst@ha
                                   stw 0,dst@l(9)
ptr = &amp;dst;                        lis 11,ptr@ha
                                   lis 9,dst@ha
                                   la 0,dst@l(9)
                                   stw 0,ptr@l(11)
*ptr = src;                        lis 9,ptr@ha
                                   lwz 11,ptr@l(9)
                                   lis 9,src@ha
                                   lwz 0,src@l(9)
                                   stw 0,0(11)
			</programlisting>
			</figure>

			<informaltable frame='topbot'>
				<tgroup cols="1" rowsep="0">
					<tbody>
						<row><entry><note>
							<title>Note</title> 
							<para>Note: The offset in the <emphasis><link linkend="GLOBAL-OFFSET-TABLE">Global Offset Table</link></emphasis> where the value of the symbol is stored is given by the assembly syntax
							<varname>symbol@got</varname>.  This syntax represents the address of the variable named
							<emphasis>symbol</emphasis>.  The offset for this assembly
							syntax cannot be any larger than 16 bits.  In cases where the
							offset is greater than 16 bits, the assembly syntax that is used
							is:</para>
							<para>- High adjusted part of the offset: <varname>symbol@got@ha</varname></para>
							<para>- High part of the offset: <varname>symbol@got@h</varname></para>
							<para>- Low part of the offset: <varname>symbol@got@l</varname></para>
						</note></entry></row>
					</tbody>
				</tgroup>
			</informaltable>

			<figure id="SMALL-MODEL-POS-IND-LOAD-STORE">
			<title>Small Model Position-Independent Load and Store</title>
			<programlisting>
C code                             Assembly code
extern int src;                    .extern src
extern int dst;                    .extern dst
extern int *ptr;                   .extern ptr
                                   .section     ".text"
                                   # GOT pointer in r31
dst = src;                         lwz 9,src@got(31)
                                   lwz 0,0(9)
                                   lwz 9,dst@got(31)
                                   stw 0,0(9)
ptr = &amp;dst;                        lwz 9,ptr@got(31)
                                   lwz 0,dst@got(31)
                                   stw 0,0(9)
*ptr = src;                        lwz 9,ptr@got(31)
                                   lwz 11,0(9)
                                   lwz 9,src@got(31)
                                   lwz 0,0(9)
                                   stw 0,0(11)</programlisting>
                        </figure>

			<figure id="LARGE-MODEL-POS-IND-LOAD-STORE">
			<title>Large Model Position-Independent Load and Store</title>
			<programlisting>
C code                             Assembly code
extern int src;                    .extern src
extern int dst;                    .extern dst
int *ptr;                          .extern ptr
                                   .section     ".text"
                                   # Assumes GOT pointer in r31
dst = src;                         addis     r6,r31,src@got@ha
                                   lwz       r6,src@got@l(r6)
                                   addis     r7,r31,dst@got@ha
                                   lwz       r7,dst@got@l(r7)
                                   lwz       r0,0(r6)
                                   stw       r0,0(r7)
ptr = &amp; dst;                       addis     r6,r31,dst@got@ha
                                   lwz       r0,dst@got@l(r6)
                                   addis     r7,r31,ptr@got@ha
                                   lwz       r7,ptr@got@l(r7)
                                   stw       r0,0(r7)
*ptr = src;                        addis     r6,r31,src@got@ha
                                   lwz       r6,src@got@l(r6)
                                   addis     r7,r31,ptr@got@ha
                                   lwz       r7,ptr@got@l(r7)
                                   lwz       r0,0(r6)
                                   lwz       r7,0(r7)
                                   stw       r0,0(r7)</programlisting>
                        </figure>

			<para CONDITION="ATR-EABI">Analogous to the symbol <varname>_SDA_BASE_</varname> described
			in the SVR4 ABI, the symbol <varname>_SDA2_BASE_</varname> shall have a value such that the
			address of any byte in the ELF sections .PPC.EMB.sdata2 and
			.PPC.EMB.sbss2 is within a signed 16-bit offset of <varname>_SDA2_BASE_</varname>'s value.
			See <emphasis><xref linkend="SPECIAL-SECTIONS-EABI"></emphasis> for details.</para>

			<para CONDITION="ATR-EABI">The following description of putting data in
			sections .sdata, .sbss, .sdata2, .sbss2, .PPC.EMB.sdata0, and
			.PPC.EMB.sbss0 makes a distinction between defined and external
			variables. In a source file, a variable that is not stored on the stack
			is either a defined variable whose definition is in the file (e.g., <varname>int
			Var;</varname> in C) or an external variable that is accessed by code in the file
			but is not defined in the file (e.g., <varname>extern int ExVar;</varname>).</para>

			<para CONDITION="ATR-EABI">A high-level language processor, such as a
			compiler, shall have a means (e.g., an option) of generating an ELF
			file that conforms to the following rules.

			<itemizedlist>
				<listitem>
					<para>Sections .sdata, .sbss, and .sdata2 shall contain at least the following:</para>
					<itemizedlist>
						<listitem>
							<para>Entries for those defined variables that are globally visible scalars of size 8 or fewer
							bytes and whose values will not be changed outside of the program (which excludes C variables
							that are volatile).</para>
							<itemizedlist>
								<listitem>
									<para>Every such defined variable whose initial value is explicitly nonzero
									and might be changed by the program shall have a .sdata entry that represents
									the variable.</para>
								</listitem>
								<listitem>
									<para>Every such defined variable whose value is initially 0 and might be
									changed shall have a .sbss entry or a .sdata entry that represents the
									variable.</para>
								</listitem>
								<listitem>
									<para>If the relocatable object generated is not intended to be part of a shared
									object, every such variable whose value cannot be changed by the program
									(such as a C variable that is const but not volatile) shall have a .sdata2
									entry that represents the variable; otherwise, such constant variables shall
									have .sdata or .sbss entries, as appropriate.</para>
								</listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>Entries produced by link editor resolution of relocation types (see <emphasis><xref linkend="RELOCATION-TYPES"></emphasis>).</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>The only external variables accessed by the generated code as .sdata, .sbss, .sdata2, .sbss2,
					.PPC.EMB.sdata0, or .PPC.EMB.sbss0 entries shall be as follows:</para>
					<itemizedlist>
						<listitem>
							<para>External variables that are scalars of 8 or fewer bytes, whose values might be changed
							by the program and whose values will not be changed outside of the program, shall be accessed
							as .sdata or .sbss entries. So the address of such a variable will be within a 16-bit signed
							offset of <varname>_SDA_BASE_</varname>, which in a shared object is the same value as
							<varname>_GLOBAL_OFFSET_TABLE_</varname>, and otherwise is loaded in r13 by a conforming application.</para>
						</listitem>
						<listitem>
							<para>When the relocatable object is not to be part of a shared object, external variables that
							are scalars of 8 or fewer bytes, whose values cannot be changed by the program and whose
							values will not be changed outside of the program, shall be accessed as .sdata2 or .sbss2
							entries. In a shared object, those constant external variables shall be accessed as
							.sdata or .sbss entries. So the address of such a variable, when not in a shared object,
							will be within a 16-bit signed offset of <varname>_SDA2_BASE_</varname>, which is loaded into r2 by a
							conforming application.</para>
						</listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist></para>

			<para CONDITION="ATR-EABI">For example, consider generating a relocatable object that will not be part of a shared object from
			the following C code fragment.

			<programlisting>
         int                  i_sdata            = 1;
         const int            i_sdata2           = 2;
         int                  i_sbss_or_sdata;
         short                s_sbss_or_sdata    = 0;
extern double                 d_sdata_or_sbss;
extern const double           d_sdata2;
extern double                 d_any_sdata_or_sbss[50];
extern const float            f_any_sdata_or_sbss[200];
extern union my_union         u_any_sdata_or_sbss;
extern const volatile float   cvf_any_sdata_or_sbss;
         int                  i_any_sdata[100]   = { 3 };
static   struct my_struct     s_any_sdata        = { 4, 6 };
         volatile const float vcf_any_sdata[5]   = { 5 };
         int                  i_any_sbss_or_sdata[100];
static   struct my_struct     s_any_sbss_or_sdata;
         volatile const float vcf_any_sbss_or_sdata[25];
</programlisting></para>

			<para CONDITION="ATR-EABI">If the code fragment defines all globally
			visible variables, a C compiler when conforming to the previously defined rules would
			place i_sdata in .sdata, i_sdata2 in .sdata2, and i_sbss_or_sdata and
			s_sbss_or_sdata in either .sbss or .sdata, while at the same time
			generating code that accesses external variable d_sdata_or_sbss using an
			offset relative to the value of <varname>_SDA_BASE_</varname> (which is in r13), accesses
			d_sdata2 using an offset relative to <varname>_SDA2_BASE_</varname> (which is in r2), and
			does not access any other external variables as .sdata, .sbss, .sdata2,
			.sbss2, .PPC.EMB.sdata0, or .PPC.EMB.sbss0 entries.</para>
		</sect2>
		<sect2 id="FUNC-CALLS">
			<title>Function Calls</title>

				<para>Direct function calls are made in programs with the Power Architecture
				<emphasis role="bold">bl</emphasis> instruction. A <varname>bl</varname> instruction can
				reach 32 MB backwards or forwards from the current position due to
				a self-relative branch displacement in the instruction. Therefore the
				size of the text segment in an executable or shared object is
				constrained when a <varname>bl</varname> instruction is used to make a function call. As
				depicted in the figure following, the <varname>bl</varname> instruction is generally used by
				a compiler to call a function.  Two possibilities exist for the
				location of the function with respect to the caller:</para>

				<itemizedlist>
					<listitem>
						<para>The called function is in the same executable or shared object as the caller.
						In this case the symbol is resolved by the link editor and the <varname>bl</varname> instructions
						branches directly to the called function as in <xref linkend="DIRECT-FUNCTION-CALL">.</para>

						<figure id=DIRECT-FUNCTION-CALL><title>Direct Function Call</title>
						<programlisting>
C code                              Assembly code
---------------------------------------------------------------
extern void function();            
function();                         bl function
						</programlisting></figure>


					</listitem>
					<listitem>
						<para>The called function is not in the same executable or shared object as the
						caller.  In this case the symbol cannot be directly resolved by the link editor.  The
						link editor generates a branch to glue code.  Subsequently the dynamic linker
						changes the glue code to branch to the function requested by the caller.

See <emphasis><link linkend="PLT">Procedure Linkage Table</link></emphasis> in <emphasis><xref linkend="PLT"></emphasis>.</para> 

					</listitem>
				</itemizedlist>

						<para>For indirect function calls, the address of the function to be
						called is placed in the CTR register and a <varname>bctrl</varname> instruction is used to
						perform the indirect branch as shown in <emphasis><xref
						linkend="ABSOLUTE-INDIRECT-FUNCTION-CALL"></emphasis>, <emphasis><xref
						linkend="SMALL-MODEL-PIC-CALL"></emphasis>, and <emphasis><xref
						linkend="LARGE-MODEL-PIC-CALL"></emphasis>.</para>

						<figure id=ABSOLUTE-INDIRECT-FUNCTION-CALL><title>Absolute Indirect Function Call</title>

						<programlisting>

C Code                           Asm Code
---------------------------------------------------
extern void function();     
extern void (*ptrfunc) ();  
                            .section .text
ptrfunc = function;         lis   r11,ptrfunc@ha  
                            lis   r9,function@ha  
                            la    r0,function@l(r9) 
                            stw   r0,ptrfunc@l(r11)
return (*ptrfunc)();        lis   r9,ptrfunc@ha  
                            lwz   r0,ptrfunc@l(r9) 
                            mtctr r0            
                            bctrl              
						</programlisting></figure>

						<para>Branches less than or equal to &plusmn; 64 KB (16-bit signed offset &plusmn; 32 KB)
						may use small model addressing.  <xref linkend="SMALL-MODEL-PIC-CALL">
						demonstrates how to make an indirect function call using small model
						position-independent branching.</para>

						<figure id=SMALL-MODEL-PIC-CALL><title>Small Model Position-Independent Indirect Function Call</title>
						<programlisting>
C Code                      Asm Code
-------------------------------------------------------------------------
extern void function();     
extern void (*ptrfunc) ();  
                            .section .text
                            /* GOT pointer is in r11  */             
ptrfunc = function;         lwz   r9,ptrfunc@got(r11)                      
                            lwz   r0,function@got(r11)                    
                            stw   r0,0(r9)                                 
                                                                        
return (*ptrfunc)();        lwz   r9,ptrfunc@got(r11)                     
                            lwz   r0,0(r9)                                 
                            mtctr r0                                    
                            bctrl                                       
						</programlisting></figure>


						<para>Branches in excess of &plusmn; 64 KB must use large model
						addressing.  <xref linkend="LARGE-MODEL-PIC-CALL"> demonstrates how to
						make an indirect function call using large model position-independent
						branching.</para>

						<figure id=LARGE-MODEL-PIC-CALL><title>Large Model Position-Independent Indirect Function Call</title>
						<programlisting>
C code                           Assembly code
--------------------------------------------------------------------
extern void function();      
extern void (*ptrfunc) ();   
                            .section .got
                            /* got_base is the start of the .got section */
                            /* offset -0x8000 from the GOT pointer.  */
                            .got_base = .+32768 
                            .ptrfunc .long ptrfunc
                            .function .long function
                            .section        ".text"

                             /* GOT pointer in r10  */
ptrfunc=function             lwz 9,.ptrfunc@got-.got_base(r11)
                             lwz 0,.function@got-.got_base(r11)
                             stw 0,0(9)

(*ptrfunc) ()                lwz 9,.ptrfunc@got-.got_base(r11)
                             lwz 0,0(9)
                             mtctr 0
                             bctrl
						</programlisting></figure>
		</sect2>

		<sect2 id="BRANCHING">
			<title>Branching</title>

			<para>The flow of execution in a program is controlled by the use of
			branch instructions.  Branch instructions can jump to locations up to 32
			MB in either direction since they hold a value with a 64 MB range
			that is relative to the current location of the program execution, which
			is defined by the architecture.</para>

			<para>The following figure shows the model for branch
			instructions.</para>

			<programlisting>
C code                        Assembly code
label:                        .L01:
   ...                             ...
   goto label;                     b .L01</programlisting>

			<para>Branch selection is provided in C with switch statements.  An
			address table is used by the compiler to implement the switch statement
			selections in cases where the case labels satisfy grouping constraints.
			Details that are not relevant are not shown by the use of simplifying
			constraints in the examples that follow.</para>

			<itemizedlist>
				<listitem>
					<para> 	r12 holds the selection expression.</para>	
				</listitem>
				<listitem>
					<para>	Case label constants begin at zero.</para>	
				</listitem>
				<listitem>
					<para>The assembler names .Lcasei, .Ldefault, and .Ltab are used for
					the case labels, the default, and the address table
					respectively.</para>
				</listitem>
			</itemizedlist>

			<para>Absolute Switch Code</para>

			<programlisting>
C code                        Assembly code
switch(j)                          cmplwi    r12, 4
{                                  bge       .Ldefault
   case 0:                         slwi      r12, 2
   ...                             addis     r12, r12, .Ltab@ha
   case 1:                         lwz       r0, .Ltab@l(r12)
   ...                             mtctr     r0
   case 3:                         bctr
   ...                             .rodata
   default:                   .Ltab:
   ...                             .long     .Lcase0
}                                  .long     .Lcase1
                                   .long     .Ldefault
                                   .long     .Lcase3
                                   .text </programlisting>

			<para>Position-Independent Switch Code, All Models</para>

			<programlisting>
C code                         Assembly code
switch(j)                            cmplwi  r12, 4
{                                    bge     .Ldefault
   case 0:                           bl      .L1
   ...                         .L1: slwi     r12, 2
   case 1:                           mflr    r11
   ...                               addi    r12, r12,.Ltab-.L1
   case 3:                           add     r0, r12, r11
   ...                               mtctr   r0
   default:                          bctr
   ...                         .Ltab:
}                                    b       .Lcase0
                                     b       .Lcase1
                                     b       .Ldefault
                                     b       .Lcase3</programlisting>
		</sect2>

		<sect2 id="DYNAM-STACK">
			<title>Dynamic Stack Space Allocation</title>


			<para>When allocated, a stack frame may be grown or shrunk dynamically as many times as necessary across the lifetime of a function.  Standard calling conventions must be maintained because a subfunction can be called after the current frame is grown and that subfunction may stack, grow, shrink, and tear down a frame between dynamic stack frame allocations of the caller.  The following constraints apply when dynamically growing or shrinking a stack frame:</para>

			<itemizedlist>
				<listitem>
					<para>Maintain 16-byte alignment.</para>	
				</listitem>
				<listitem>
					<para>Stack pointer adjustments shall be performed atomically so that at all times the value of the backchain word is valid.</para>	
				</listitem>
				<listitem>
					<para>Maintain addressability to the previously allocated local variables.</para>
				</listitem>
			</itemizedlist>

			<note><title>note</title><para>Note: Using a frame pointer is the recognized method for maintaining addressability to arguments or local variables.  For correct behavior in the cases of <varname>setjmp()</varname> and <varname>longjmp()</varname> the frame pointer shall be allocated in a nonvolatile general-purpose register.</para></note>


			<figure ID="BEFORE-ALLOCA"><title>Before Dynamic Stack Allocation</title>
			<mediaobject><imageobject><imagedata scale=75 fileref="graphics/Before-Alloca.png" format="PNG"></imageobject>

			<caption><para>An example organization of a stack frame before a dynamic allocation.</para></caption>
			</mediaobject>
			</figure>

			<figure><title>Example code to allocate n bytes:</title>
			<screen>
#define n 13
char *a = alloca(n);
rnd(x) = round x to be multiple of stack alignment
psave = size of parameter save area (may be zero).
p = rnd(sizeof(psave&plus;8)) ; Offset to the start of the dynamic allocation 

lwz  0,0(1)           ; Load backchain word.
mr   31,1             ; Frame pointer to access previously allocated.
stwu 0,&minus;rnd(n&plus;15)(1)  ; Store new backchain, quadword-aligned.
addi 3,1,p            ; R3 = new data area following parmameter save area.

			</screen></figure>

			<note><title>Note</title><para>Note: Additional instructions might be needed to align the
			allocated data area or the stack pointer.  Additional instructions will be necessary for an
			allocation of variable size.</para></note>

			<figure ID="AFTER-ALLOCA"><title>After Dynamic Stack Allocation</title>
			<mediaobject><imageobject><imagedata scale=75 fileref="graphics/After-Alloca.png" format="PNG"></imageobject>

			<caption><para>An example organization of a stack frame after a dynamic allocation.</para></caption>
			</mediaobject>
			</figure>

		</sect2>
	</sect1>
	<sect1 id="DWARF-DEF">
		<title>DWARF Definition</title>

		<para>Although this ABI itself does not define a debugging format, DWARF 
		(<emphasis>Debug with Arbitrary Record Format</emphasis>) (see <emphasis><xref linkend="REFERENCES"></emphasis>) is defined here for
		systems that implement the DWARF specification.</para>

		<para>The DWARF specification is used by compilers and
		debuggers to aid source-level or symbolic debugging. However, the
		format is not biased toward any particular compiler or debugger.</para>

		<para>Per the DWARF specification, a mapping from Power Architecture registers to register numbers is
		required as described in <xref linkend="REG-MAPPINGS">.</para>

		<para>Special Purpose Registers or SPRs are mapped into DWARF as 100 plus
		their SPR number. Performance Monitor Registers or PMRs are mapped into
		DWARF as 2048 plus the PMR number. Kernel debuggers that display
		privileged registers are to use the following DWARF register number mapping.</para>

		<para>All instances of the Power Architecture use the following mapping
		for encoding registers into DWARF.</para>


		<table  id="REG-MAPPINGS" frame="none">
		<title>Register Mappings</title>
			<tgroup cols='3' colsep='0' rowsep='0'>
				<colspec colwidth='160' colname='c1' align="left">
				<colspec colwidth='80' colname='c2' align="left">
				<colspec colwidth='80' colname='c3' align="left">
				<thead>
					<row rowsep="1">
						<entry namest="c1">Register Name</entry>
						<entry namest="c2">Number</entry>
						<entry namest="c3">Abbreviation</entry>
					</row>
				</thead>
				<tbody>

					<row>
						<entry>General-purpose registers</entry>
						<entry>0-31</entry>
						<entry>R0-R31</entry>
					</row>

					<row>
						<entry>Floating-point registers</entry>
						<entry>32-63</entry>
						<entry>F0-F31</entry>
					</row>

					<row>
						<entry>Condition register</entry>
						<entry>64</entry>
						<entry>CR</entry>
					</row>

					<row>
						<entry>Floating-point status and control register</entry>
						<entry>65</entry>
						<entry>FPSCR</entry>
					</row>

					<row>
						<entry>Machine state register</entry>
						<entry>66</entry>
						<entry>MSR</entry>
					</row>

					<row>
						<entry>Accumulator</entry>
						<entry>99</entry>
						<entry>ACC</entry>
					</row>

					<row>
						<entry>SPRs</entry>
						<entry>100-1123</entry>
						<entry>LR, CTR, etc.</entry>
					</row>

					<row>
						<entry>Vector registers</entry>
						<entry>1124-1155</entry>
						<entry>V0-V31</entry>
					</row>

					<row>
						<entry>Reserved</entry>
						<entry>1156-1199</entry>
						<entry></entry>
					</row>

					<row>
						<entry>SPE high parts of GPRs</entry>
						<entry>1200-1231</entry>
						<entry></entry>
					</row>

					<row>
						<entry>Reserved</entry>
						<entry>1232-2047</entry>
						<entry></entry>
					</row>


					<row>
						<entry>Device control registers</entry>
						<entry>3072-4095</entry>
						<entry>DCRs</entry>
					</row>

					<row>
						<entry>Performance monitor registers</entry>
						<entry>4096-5120</entry>
						<entry>PMRs</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

	</sect1>
	<sect1 id="EXCEPTION-HANDLING" CONDITION="ATR-CXX">
		<title>Exception Handling</title>

		<para>Where exceptions can be thrown or caught by a function, or thrown through that function,
		or where a thread can be canceled from within a function, the locations where nonvolatile
		registers have been saved must be described with unwind information.  The format of this
		information is based on the DWARF Call Frame Information with extensions.</para>

		<para>Any implementation that generates unwind information must also provide exception handling
		functions that are the same as those described in the Itanium C++ ABI, the normative text on
		the issue.  See <emphasis><xref linkend="REFERENCES"></emphasis> for directions on obtaining this information.</para>
	</sect1>
	</chapter>

<!-- Keep this comment at the end of the file
Local Variables:
mode: sgml
sgml-parent-document: ("PPC-elf32abi.sgml" "book" "chapter")
End:
-->
